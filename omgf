#!/usr/bin/env bash

shopt -s extglob
# exit when any command fails
set -e
# treat unset variables as error
set -u

# shellcheck disable=SC2223
: ${OMGF_DATAPATH:=.}
# shellcheck disable=SC2223
: ${OMGF_CHANGELOG:=CHANGELOG.md}
# shellcheck disable=SC2223
: ${OMGF_VERSION:=VERSION}
# shellcheck disable=SC2223
: ${OMGF_DEV:=dev}
# shellcheck disable=SC2223
: ${OMGF_RELEASE:=release}
# shellcheck disable=SC2223
: ${OMGF_MASTER:=master}
# shellcheck disable=SC2223
: ${OMGF_ORIGIN:=origin}
# shellcheck disable=SC2223
: ${OMGF_UPSTREAM:=${OMGF_ORIGIN}}
# shellcheck disable=SC2223
: ${OMGF_CHANGELOG_HEADER:=# Change Log
All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](http://keepachangelog.com/)
and this project adheres to [Semantic Versioning](http://semver.org/).}
# shellcheck disable=SC2223
: ${OMGF_STABLE_PREFIX:=v}
: ${COLUMNS:=$(tput cols)}
: ${LINES:=$(tput lines)}

function main {

  function msg_start {
    [[ ${verbose} -eq 0 ]] && return
    if stdoutpipe || [[ ${COLUMNS} -lt 41 ]]; then
      echo -n "${1}" && return 0
    fi
    echo -n "[ "
    save_cursor_position
    echo " ....  ] ${1}"
  }

  function msg_end {
    [[ ${verbose} -eq 0 ]] && return
    if stdoutpipe || [[ ${COLUMNS} -lt 41 ]]; then
      echo " [ ${1} ]" && return 0
    fi
    set_cursor_position
    echo "${1}"
  }

  function stdout_silent {
    [[ ${verbose} == 0 ]] && exec 5<&1 && exec 1>/dev/null
    return 0
  }

  function stdout_verbose {
    [[ ${verbose} == 0 ]] && exec 1<&5
    return 0
  }

  function err {
    echo "$(basename "${0}") error: ${1}" >&2
    exit "${2:-1}"
  }

  function setcolor {
    local c
    c=${1:-always}
    case ${c} in
      always|never|auto)
        color=${c}
        return 0
      ;;
    esac
    return 2
  }

  function stdoutpipe {
    readlink /proc/$$/fd/1 | grep -q "^pipe:"
  }

  function colorize {
    [[ ${color} == never ]] && echo -n "${1}" && return
    [[ ${color} == auto ]] && stdoutpipe && echo -n "${1}" && return
    local c
    c="${2:-${GREEN}}"
    tput setaf "${c}"
    echo -n "${1}"
    tput sgr0
  }

  function clear_stdin {
    while read -r -t 0; do read -r; done
  }

  function save_cursor_position {
    local curpos oldstty
    curpos="1;1"
    exec < /dev/tty
    oldstty=$(stty -g)
    stty raw -echo min 0
    echo -en "\033[6n" >/dev/tty
    # shellcheck disable=SC2162
    read -d"R" curpos </dev/tty
    stty "${oldstty}"
    pos_x=$( echo "${curpos#??}" | cut -d";" -f1 )
    pos_y=$( echo "${curpos#??}" | cut -d";" -f2 )
  }

  function set_cursor_position {
    [[ "${pos_x}" == "${LINES}" ]] && : $(( pos_x-- ))
    tput cup $(( pos_x-1 )) $(( pos_y-1 ))
  }

  function strtolower {
    echo "${1}" | tr '[:upper:]' '[:lower:]'
  }

  function trim {
    echo "${1}" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//'
  }

  function confirm {
    [[ ${yes} == 1 ]] && return
    if [[ ${is_stdin} == 0 ]]; then
      stdout_verbose
      echo -n "${1:-"Are you sure?"} [YES/No] "
      save_cursor_position
      clear_stdin
      read -r
      [[ -z "${REPLY}" ]] && set_cursor_position && echo "yes"
      stdout_silent
    else
      read -r
    fi
    [[ "${REPLY}" =~ ^y(es)?$ || -z "${REPLY}" ]] && return 0
    [[ "${REPLY}" =~ ^no?$ ]] && exit
    confirm "Type"
  }

  function git_status_empty {
    [[ -z "$(git status --porcelain)" ]]
  }

  # make git return only error to stderr
  function gch {
    local out
    out="$(git checkout "$@" 2>&1)" \
      || echo "${out}" >&2
  }

  function gc {
    git commit "$@"
  }

  # make git return only error to stderr
  function git_fetch {
    msg_start "Fetching $*"
    local out
    out="$(git fetch --update-head-ok "$@" 2>&1)" \
      || err "${out}"
    msg_end "${DONE}"
  }

  # make git return only error to stderr
  function git_tag {
    local out
    out="$(git tag "$@" 2>&1)" \
      || echo "${out}" >&2
  }

  # make git return only error to stderr
  function git_merge {
    local out
    out="$(env GIT_EDITOR=: git merge "$@" 2>&1)" \
      || echo "${out}" >&2
  }

  function git_push {
    msg_start "Pushing $*"
    local out
    out="$(git push "$@" 2>&1)" \
      || err "${out}"
    msg_end "${DONE}"
  }

  function create_branch {
    msg_start "Creating branch '${1}'"
    gch -b "${1}"
    msg_end "${DONE}"
  }

  function git_branch_create {
    local to
    to="${2:-HEAD}"
    remote_branch_exists "${1}" \
      && to="${OMGF_ORIGIN}/${1}"
    msg_start "Creating branch '${1}' on '${to}'"
    git branch "${1}" "${to}" >/dev/null \
      || exit 1
    msg_end "${DONE}"
  }

  function local_branch_exists {
    git rev-parse --verify "${1}" >/dev/null 2>&1
  }

  function remote_branch_exists {
    git ls-remote --heads "${OMGF_ORIGIN}" 2>/dev/null | grep -q "${REFSHEADS}/${1}"$
  }

  function git_tag_exists {
    git tag | grep -q "^${1}"
  }

  function has_tag {
    [[ -n $(git tag --merged "${1}" -l "${2}") ]]
  }

  function git_repo_exists {
    [[ -d .git ]]
  }

  function git_remote_exists {
    git config remote."${OMGF_ORIGIN}".url >/dev/null \
      || err "Remote url for '${OMGF_ORIGIN}' does not exist."
  }

  function git_commit_diff {
    [[ "$( git rev-parse "${1}" )" != "$( git rev-parse "${2}" )" ]]
  }

  function git_version_diff {
    [[ "$(git show "${1}":"${OMGF_VERSION}" | cut -d. -f1-2)." != "${2}" ]]
  }

  function current_branch {
    git rev-parse --abbrev-ref HEAD
  }

  function git_current_commit {
    git rev-parse HEAD
  }

  function git_stash {
    git_status_empty && return 0
    msg_start "Stashing files"
    # shellcheck disable=SC2015
    git add -A >/dev/null \
      && git stash >/dev/null \
      || err "Unable to stash changes." 1
    stashed=1
    msg_end "${DONE}"
  }

  function git_stash_pop {
    [[ ${stashed} == 0 ]] && return 0
    msg_start "Popping stashed files"
    git stash pop >/dev/null || { msg_end "${FAIL}"; return 1; }
    msg_end "${DONE}"
  }

  function git_has_commits {
    git log >/dev/null 2>&1
  }

  function is_merged_to {
    git branch --merged "${2}" | grep -q "${1}"
  }

  # idea:
  # merge upwards preserving conflicts
  # merge downwards ignoring VERSION and CHANGELOG conflicts
  # upwards: feature->dev->release->master, hotfix->master
  # downwards: master->release->dev
  function merge_fromto {
    local stream
    stream='upwards'
    [[ "${1}" == "${OMGF_MASTER}" || "${2}" == "${OMGF_DEV}" ]] \
      && stream='downwards'
    msg_start "Merging ${stream} from '${1}' to '${2}'"
    is_merged_to "${1}" "${2}" \
      && msg_end "${SKIP}" \
      && return
    gch "${2}" \
      && git_merge_stream "${1}" "${stream}" \
      && msg_end "${DONE}"
  }

  function git_merge_stream {
    [[ "${2}" == 'upwards' ]] \
      && git_merge --no-ff "${1}" \
      && return \
      || exit 5
    git_merge --no-ff --no-commit "${1}" 2>/dev/null
    gch --ours "${OMGF_VERSION}" \
      && gch --ours "${OMGF_CHANGELOG}" \
      && git add . \
      && git_merge --continue \
      || exit 5
  }

  function delete_remote_branch {
    msg_start "Deleting remote branch '${1}'"
    ! remote_branch_exists "${1}" \
      && msg_end "${SKIP}" \
      && return
    #TODO: used to be:
    #git push "${OMGF_ORIGIN}" ":${REFSHEADS}/${1}" 2>&1
    git push -d "${OMGF_ORIGIN}" "${1}"
    msg_end "${DONE}"
  }

  function delete_branch {
    [[ "$(current_branch)" != "${1}" ]] \
      || err "Cannot delete checked branch" 1
    delete_remote_branch "${1}"
    msg_start "Deleting local branch '${1}'"
    git branch -d "${1}"
    msg_end "${DONE}"
  }

  #TODO add verification?
  function load_version {
    git show "${1:-$(current_branch)}:VERSION" \
      || exit 1
  }

  function master_last_change {
    git cherry -v "${OMGF_DEV}" "${OMGF_MASTER}" | tail -n1 | cut -d" " -f2
  }

  # ${1} filepath
  # ${2} default content
  # ${3} allow empty file
  function init_file {
    [[ -f "${1}" ]] && return 0
    [[ -z "${1}" && ${3} == 1 ]] && return 0
    local or_empty_msg
    or_empty_msg=
    [[ ${3} == 0 ]] && or_empty_msg=" or empty"
    [[ ${conform} == 1 ]] \
      || err "Missing${or_empty_msg} file '${1}'." 3
    local message
    message="Initializing '${1}' file"
    msg_start "${message}"
    echo "${2}" > "${1}" || return 1
    git add "${1}" >/dev/null \
      && gc -m "${message}" >/dev/null \
      || exit 1
    msg_end "${DONE}"
  }

  function initial_commit {
    git_status_empty && return 0
    msg_start "Initial commit"
    # shellcheck disable=SC2015
    git add -A >/dev/null \
      && gc -m "Commit initial files" >/dev/null \
      || err "Unable to commit existing files."
    msg_end "${DONE}"
  }

  function parse_version {
    echo "${1}" | sed -n 's/.*\([0-9]\+\.[0-9]\+\.[0-9]\+\).*/\1/p'
  }

  function verlte {
    [ "${1}" = "$(echo -e "${1}\n${2}" | sort -V | head -n1)" ]
  }

  function validate_requirements {
    bash_min_version=3.2
    git_min_version=1.8.0
    bash_version="$(parse_version "$(bash --version 2>/dev/null)")"
    git_version="$(parse_version "$(git --version 2>/dev/null)")"
    verlte "${bash_min_version}" "${bash_version}" \
      || err "OMGF requires Bash version ${bash_min_version} or later (you have ${bash_version:-no Bash installed})."
    verlte "${git_min_version}" "${git_version}" \
      || err "OMGF requires Git version ${git_min_version} or later (you have ${git_version:-no Git installed})."
  }

  # 1) validate repository existence
  # 2) validate repository consistency:
  # - at least one commit
  # - master branch
  function validate_git_repository {
    if ! git_repo_exists; then
      [[ ${conform} == 0 ]] \
        && err "Git repository does not exist." 3
      msg_start "Initializing git repository"
      git init >/dev/null || return 1
      msg_end "${DONE}"
    fi
    if ! git_has_commits; then
      [[ ${conform} == 0 ]] \
        && err "Git repository without commits." 3
      initial_commit
    elif ! local_branch_exists "${OMGF_MASTER}"; then
      [[ ${conform} == 0 ]] \
        && err "Missing branch '${OMGF_MASTER}'." 3
      git_branch_create "${OMGF_MASTER}"
    fi
  }

  # validate ${OMGF_VERSION} and ${OMGF_CHANGELOG} files
  function validate_gf_files {
    #TODO validate
    init_file "${OMGF_VERSION}" "0.0.0" 0
    init_file "${OMGF_CHANGELOG}" "${OMGF_CHANGELOG_HEADER}" 1
  }

  # validate tag on ($)master
  function validate_vertag {
    local ver
    ver=$(load_version "${1}")
    has_tag "${1}" "${ver}" \
      && return
    [[ ${conform} == 0 ]] \
      && err "Missing tag '${ver}' on branch '${1}'." 3
    git_tag "${ver}" "${1}" \
      || exit 1
  }

  # 1) validate ${OMGF_DEV} branch
  # 2) validate ${OMGF_DEV} is up to date with master
  function validate_dev {
    local_branch_exists "${OMGF_DEV}" \
      && return
    [[ ${conform} == 0 ]] \
      && err "Missing branch '${OMGF_DEV}'." 3
    git_branch_create "${OMGF_DEV}" "${OMGF_MASTER}"
    is_merged_to "${OMGF_MASTER}" "${OMGF_DEV}" \
      && return
    [[ ${conform} == 0 ]] \
      && err "Branch '${OMGF_MASTER}' is not merged to '${OMGF_DEV}'." 3
    merge_fromto "${OMGF_MASTER}" "${OMGF_DEV}"
  }

  function validate_release {
    if ! local_branch_exists "${OMGF_RELEASE}"; then
      [[ ${conform} == 0 ]] \
        && err "Missing branch '${OMGF_RELEASE}'." 3
      git_branch_create "${OMGF_RELEASE}" "${OMGF_DEV}" || return 1
    fi
  }

  function validate_dev_version {
    ver=$(load_version "${OMGF_DEV}")
    vergt "${ver}" "$(load_version "${OMGF_MASTER}")" \
      && return
    [[ ${conform} == 0 ]] \
      && err "Version on '${OMGF_DEV}' must be greater than on '${OMGF_MASTER}'." 3
    gch "${OMGF_DEV}" \
      || exit 1
    increment_version "${ver}" 1
  }

  # validate git status
  function validate_status_empty {
    git_status_empty \
      && return
    [[ ${stash} == 1 ]] \
      && git_stash \
      && return
    err "Uncommitted changes." 4
  }

  function validate_changelog_heading {
    grep -qE "^# " "${OMGF_CHANGELOG}" && return 0
    [[ "${conform}" == 1 ]] \
      || err "File ${OMGF_CHANGELOG} missing '# Heading'." 3
    local msg
    msg="Add default heading to ${OMGF_CHANGELOG}"
    msg_start "${msg}"
    echo -e "${OMGF_CHANGELOG_HEADER}\n$(cat "${OMGF_CHANGELOG}")" > "${OMGF_CHANGELOG}" \
      && gc -am "${msg}" >/dev/null \
      || exit 1
    msg_end "${DONE}"
  }

  function gf_validate {
    validate_requirements
    validate_git_repository
    validate_status_empty
    validate_gf_files
    validate_vertag "${OMGF_MASTER}"
    validate_dev
    validate_dev_version
    validate_release
    validate_changelog_heading
  }

  #TODO: dissolve
  function auto_process {
    case "${1%%-*}" in
      ${OMGF_MASTER}|${OMGF_STABLE_PREFIX}+([0-9]).+([0-9])) create_hotfix ;;
      ${OMGF_DEV}) create_feature ;;
      ${FEATURE}) merge_feature ;;
      ${OMGF_RELEASE}) merge_release ;;
      ${HOTFIX}) release_hotfix ;;
    esac
  }

  function gf_process {
    [[ ${#} -gt 2 ]] \
      && err "Too many arguments." 2
    local source
    source=$(current_branch)
    name=${2:-"$(whoami)"}
    git check-ref-format "${REFSHEADS}/${name}" \
      || err "Invalid branch name format '${name}'." 2
    case "${1:-"${source%%-*}"}" in
      ${HOTFIX})
        gf_hotfix
        ;;
      ${OMGF_RELEASE})
        gf_release
        ;;
      ${FEATURE})
        gf_feature
        ;;
      ${PULL})
        gf_pull
        ;;
      ${PUSH})
        gf_push
        ;;
      *)
        err "Unknown branch." 2
        ;;
    esac
  }

  function confirm_checkout_if_exists {
    [[ "$(current_branch)" == "${1}" ]] \
      && err "You are on branch '${1}'." 6
    ! local_branch_exists "${1}" \
      && ! remote_branch_exists "${1}" \
      && return
    confirm "* Branch '${1}' already exists, checkout?"
    gch "${1}"
  }

  function gf_release {
    # local last_merge valid_commits confirmed
    # confirmed=0
    # last_merge="$(git reflog show "${OMGF_DEV}" --format="%h:%gs" | grep -m1 ":merge ${OMGF_RELEASE}:" | cut -d: -f1)"
    # # commits on dev before last release merge
    # valid_commits="$(git reflog show "${OMGF_DEV}" --format="%H")"
    # [[ -n "${last_merge}" ]] && valid_commits="$(echo "${valid_commits}" | sed "/${last_merge}/Q")"
    # # on invalid commit?
    # if ! echo "${valid_commits}" | grep -q "$(git_current_commit)"; then
    #   gf_confirm_checkout "${OMGF_DEV}" "* Unable to create '${OMGF_RELEASE}' from current commit. Create '${OMGF_RELEASE}' from '${OMGF_DEV}' instead?" \
    #     || return 1
    #   confirmed=1
    # fi
    [[ "$(current_branch)" != "${OMGF_DEV}" ]] \
      && err "Releasing is only available from '${OMGF_DEV}'."
    ver=$(load_version "${OMGF_DEV}")
    confirm "* Release '${ver}' from '${OMGF_DEV}' branch?"
    merge_fromto "${OMGF_DEV}" "${OMGF_RELEASE}"
    gch "${OMGF_DEV}"
    update_changelog_header
    increment_version "${ver}" 1
  }

  function create_feature {
    local feature_name
    feature_name="${1}"
    confirm_checkout_if_exists "${feature_name}" \
      && return
    confirm "* Create branch '${feature_name}' from branch '${OMGF_DEV}'?"
    create_branch "${feature_name}"
  }

  function create_hotfix {
    local source ver
    source=${HOTFIX}-${1:-"$(whoami)"}
    ver=$(load_version "${OMGF_MASTER}")
    confirm_checkout_if_exists "${source}" \
      && return
    confirm "* Create hotfix '${source}' from '${OMGF_MASTER}'?"
    gch "${OMGF_MASTER}"
    #[[ "${gf_branch}" != "${OMGF_MASTER}" ]] \
    #  && create_stable_branch
    create_branch "${source}"
  }

  function merge_release {
    confirm "* Merge '${OMGF_RELEASE}' branch into '${OMGF_DEV}'?"
    merge_fromto "${gf_branch}" "${OMGF_DEV}"
  }

  function gf_release_release {
    local source
    source=$(current_branch)
    git_version_diff "${OMGF_MASTER}" "${major}.${minor}." \
      || err 'Branch already released.'
    # shellcheck disable=SC2015
    [[ ${request} == 1 ]] \
      && confirm "* Request merge '${OMGF_RELEASE}' to '${OMGF_MASTER}'?" \
      || confirm "* Merge '${OMGF_RELEASE}' to '${OMGF_MASTER}'?"
    update_changelog_header
    merge_fromto "${OMGF_MASTER}" "${source}"
    [[ ${request} == 1 ]] \
      && gf_request "${OMGF_MASTER}" \
      && return
    merge_fromto "${source}" "${OMGF_MASTER}"
    git_tag "${master}".0
    merge_fromto "${source}" "${OMGF_DEV}"
  }

  function gf_get_compare_url {
    url="$(git config remote."${OMGF_ORIGIN}".url)"
    url="$(trim_url "${url}")"
    case "${url}" in
      *"${GITHUB}"*) echo "https://${url}/compare/${1}...${2}" ;;
      *"${BITBUCKET}"*) echo "https://${url}/compare/${2}..${1}" ;;
      *) echo "" ;;
    esac
  }

  function update_changelog_header {
    local header tmpfile compare_url prev_tag
    msg_start "Updating version history header"
    header="## [${major}.${minor}.${patch}] - $(date "+%Y-%m-%d")"
    prev_tag="$(git tag | sort -V | tail -n1 )"
    compare_url="$(gf_get_compare_url "${prev_tag}" "${master}.${patch}" )"
    [[ -n "${compare_url}" ]] \
      && compare_url="[${major}.${minor}.${patch}]: ${compare_url}" \
      || compare_url="[${major}.${minor}.${patch}]: ${prev_tag}..${master}.${patch}"
    tmpfile="$(mktemp)"
    gawk -v header="${header}" -v compare_url="${compare_url}" '
      BEGIN {
        writemsg=1
        writeurl=1
      }
      /^\[Unreleased\]/ { next }
      writemsg == 1 && /^## / {
        print header
        writemsg=0
        if($0 ~ "^## \\[?Unreleased\\]?") { next }
        print ""
      }
      writeurl == 1 && /^\[/ && ! /^\[Unreleased\]/ {
        print compare_url
        writeurl=0
      }
      {print}
      ENDFILE {
        if(writemsg==1) { print header }
        if(writeurl==1) { print ""; print compare_url }
      }
      ' "${OMGF_CHANGELOG}" > "${tmpfile}"
    cat "${tmpfile}" > "${OMGF_CHANGELOG}"
    gc -am "Update ${OMGF_CHANGELOG} header" >/dev/null || return 1
    msg_end "${DONE}"
  }

  function gf_write_changelog_line {
    local tmpfile compare_url
    tmpfile="$(mktemp)"
    compare_url="$(gf_get_compare_url "${OMGF_MASTER}" "${OMGF_DEV}")"
    [[ -n "${compare_url}" ]] \
      && compare_url="[Unreleased]: ${compare_url}" \
      || compare_url="[Unreleased]: ${OMGF_MASTER}..${OMGF_DEV}"
    gawk -v keyword="${1}" -v next_keywords="${2}" -v message="${3}" -v compare_url="${compare_url}" '
      function print_unreleased () { print "## [Unreleased]" }
      function print_keyword () { print "### " keyword }
      function print_message () { print " - " message }
      BEGIN {
        writemsg=1
        unreleased=0
        writeurl=1
      }
      /^## \[?Unreleased\]?/ { unreleased=1 }
      writemsg == 1 && unreleased == 0 && /^## / && ! /^## \[?Unreleased\]?/ {
        print_unreleased()
        print_keyword()
        print_message()
        print ""
        writemsg=0
      }
      writemsg == 1 && $0 ~ "^## " next_keywords && ! /^## \[?Unreleased\]?/ {
        print_keyword()
        print_message()
        print ""
        writemsg=0
      }
      /^\[Unreleased\]/ { writeurl=0 }
      writeurl == 1 && /^\[/ {
        print compare_url
        writeurl=0
      }
      {print}
      writemsg == 1 && $0 == "### " keyword {
        print_message()
        writemsg=0
      }
      ENDFILE {
        if(writemsg == 1) {
          print ""
          if(unreleased == 0) { print_unreleased() }
          print_keyword()
          print_message()
        }
        if(writeurl==1) { print compare_url }
      }
    ' "${OMGF_CHANGELOG}" > "${tmpfile}"
    cat "${tmpfile}" > "${OMGF_CHANGELOG}"
  }

  function gf_update_changelog {
    local commits
    commits="$(git log "${2:-OMGF_DEV}".."$(current_branch)" --pretty=format:"*   %h %s")"
    stdout_verbose
    echo
    echo "***"
    echo "* Please enter the $(current_branch) description for ${OMGF_CHANGELOG}."
    echo "*"
    echo "* Keywords:"
    echo "*   $(echo "${CHANGELOG_KEYWORDS[@]}" | sed "s/ /, /g;s/${CHANGELOG_KEYWORDS[${1}]}/${CHANGELOG_KEYWORDS[${1}]} (default)/")"
    echo "*"
    echo "* Commits of '$(current_branch)':"
    echo "${commits}"
    echo "*"
    REPLY=
    if [[ ${is_stdin} == 0 ]]; then
      echo "Type \"Keyword: Message\", empty line to end:"
      clear_stdin
    fi
    local message keyword next_keywords i found
    while read -e -r message; do
      [[ -z "${message}" ]] && break
      history -s "${message}"
      keyword="$(trim "$(echo "${message}" | cut -sd':' -f1)")"
      next_keywords=
      found=0
      i=
      if [[ -n "${keyword}" ]]; then
        for i in "${!CHANGELOG_KEYWORDS[@]}"; do
          [[ "${CHANGELOG_KEYWORDS[i]}" != "${keyword}"* ]] && continue
          keyword="${CHANGELOG_KEYWORDS[i]}"
          found=1
          break
        done
        if [[ "${found}" == 0 ]]; then
          echo "'${keyword}' is not a valid keyword"
          continue
        fi
      else
        i=${1}
        keyword="${CHANGELOG_KEYWORDS[${i}]}"
      fi
      for ((index="${i}+1"; index < ${#CHANGELOG_KEYWORDS[@]}; index++)); do
        next_keywords="${next_keywords}|^### ${CHANGELOG_KEYWORDS[index]}"
      done
      [[ "${found}" == 1 ]] && message="$(echo "${message}" | cut -d':' -f2-)"
      gf_write_changelog_line "${keyword}" "${next_keywords}" "$(trim "${message}")"
    done
    stdout_silent
    msg_start "Updating version history"
    if ! git_status_empty 2>/dev/null; then
      gc -am "Update ${OMGF_CHANGELOG}" >/dev/null || return 1
      msg_end "${DONE}"
    else
      msg_end "${SKIP}"
    fi
  }

  function merge_feature {
    local source
    source=$(current_branch)
    is_merged_to "${source}" "${OMGF_DEV}" \
      && err "Nothing to merge." 6
    # shellcheck disable=SC2015
    [[ ${request} == 1 ]] \
      && confirm "* Request merge '${source}' into '${OMGF_DEV}'?" \
      || confirm "* Merge '${source}' into '${OMGF_DEV}'?"
    merge_fromto "${OMGF_DEV}" "${source}"
    gf_update_changelog 0
    [[ ${request} == 1 ]] \
      && gf_request "${OMGF_DEV}"
    merge_fromto "${source}" "${OMGF_DEV}"
    delete_branch "${source}"
  }

  ### Increments the part of the string
  ## $1: version itself
  ## $2: number of part: 0 – major, 1 – minor, 2 – patch
  function increment_version {
    msg_start "Increment version number"
    local array=("$(echo "${1}" | tr . '\n')")
    array[${2}]=$((array[${2}] + 1))
    [[ ${2} -lt 2 ]] \
      && array[2]=0
    [[ ${2} -lt 1 ]] \
      && array[1]=0
    ver=$(local IFS=.; echo "${array[*]}")
    echo "${ver}" > "${OMGF_VERSION}"
    gc -am "Increment version number"
    msg_end "${DONE}"
  }

  function release_hotfix {
    local source dest verh verd
    source=$(current_branch)
    dest=${OMGF_MASTER}
    verh=$(load_version)
    verd=$(load_version "${OMGF_MASTER}")
    # shellcheck disable=SC2015
    [[ "${verd%.*}" != "${verh%.*}" ]] \
      && dest="${verh%.*}" \
      && verd="$(load_version "${dest}")" \
      && confirm "* Obsolete version. Merge to a seperate stable branch instead of releasing?" \
      || confirm "* Release the hotfix?"
    is_merged_to "${source}" "${dest}" \
      && err "Nothing to merge." 6
    increment_version "${verd}" 2
    gf_update_changelog 4 "${dest}"
    update_changelog_header
    [[ ${request} == 1 ]] \
      && gf_request "${dest}" \
      && return
    merge_fromto "${source}" "${dest}"
    git_tag "$(load_version)"
    [[ "${dest}" == "${OMGF_MASTER}" ]] \
      && merge_fromto "${OMGF_MASTER}" "${OMGF_RELEASE}" \
      && merge_fromto "${OMGF_MASTER}" "${OMGF_DEV}"
    delete_branch "${source}"
  }

  function gf_pull_branch {
    remote_branch_exists "${1}" \
      || return
    git_fetch "${OMGF_ORIGIN}" "${1}:${1}"
  }

  function gf_pull {
    git_remote_exists \
      && git_fetch --tags \
      && gf_pull_branch "${OMGF_DEV}" \
      && gf_pull_branch "${OMGF_MASTER}" \
      && gf_pull_branch "${OMGF_RELEASE}" \
      || return $?
    local stable
    for stable in $(git branch -r | grep 'origin/' | grep -o 'v[0-9]\+\.[0-9]\+'); do
      gf_pull_branch "${stable}" \
        || return $?
    done
  }

  function gf_push {
    git_remote_exists \
      && git_push --tags \
      && git_push "${OMGF_ORIGIN}" "${OMGF_DEV}" \
      && git_push "${OMGF_ORIGIN}" "${OMGF_MASTER}" \
      || return $?
    local_branch_exists "${OMGF_RELEASE}" \
      && { git_push "${OMGF_ORIGIN}" "${OMGF_RELEASE}" || return $?; }
    for stable in $(git branch -r | grep 'origin/' | grep -o 'v[0-9]\+\.[0-9]\+'); do
      local_branch_exists "${stable}" \
        && { git_push "${OMGF_ORIGIN}" "${stable}" || return $?; }
    done
  }

  function gf_request {
    git_remote_exists
    [[ "${OMGF_ORIGIN}" == "${OMGF_UPSTREAM}" ]] \
      || git_push "${OMGF_ORIGIN}" "${1}"
    git_push "${OMGF_ORIGIN}" "${1}"
    gf_request_url "${1}"
  }

  function trim_url {
    local url
    url="${1#https://}"
    echo "${url}" | grep -q ":" \
      && url="${url#*@}" \
      && url="${url/://}" \
      && url="${url/.git/}"
    echo "${url}"
  }

  function gf_request_url {
    local url upstream_url to
    to="${1:-${OMGF_DEV}}"
    url="$(git config remote."${OMGF_ORIGIN}".url)"
    url="$(trim_url "${url}")"
    upstream_url="$(git config remote."${OMGF_UPSTREAM}".url)"
    upstream_url="$(trim_url "${upstream_url}")"
    stdout_verbose
    echo -n "Pull request URL: "
    case "${url}" in
      *"${GITHUB}"*)
        # shellcheck disable=SC1003
        [[ "${url}" == "${upstream_url}" ]] \
          && echo "https://${url}/compare/${to}...${gf_branch}?expand=1" \
          || echo "https://${upstream_url}/compare/${to}...$(echo "${url}" | cut -d'/' -f2)%3A${gf_branch}?expand=1"
      ;;
      *"${BITBUCKET}"*)
        # shellcheck disable=SC1003
        [[ "${url}" == "${upstream_url}" ]] \
          && echo "https://${url}/compare/${gf_branch}..$(echo "${url}" | cut -d'/' -f2-3)%3A${to}" \
          || echo "https://${url}/compare/${gf_branch}..$(echo "${upstream_url}" | cut -d'/' -f2-3)%3A${to}"
      ;;
      *)
        err "Remote server name not recognized."
      ;;
    esac
    stdout_silent
  }

  function gf_usage {
    local usage_file shift_left first_line other_content
    if [[ -z "${OMGF_USAGE+x}" ]]; then
      usage_file="${OMGF_DATAPATH}/${script_name}.usage"
      [ -f "${usage_file}" ] \
        || err "Usage file not found"
      first_line="$(head -n1 "${usage_file}")"
      other_content="$(tail -n+2 "${usage_file}")"
    else
      first_line="$(echo "${OMGF_USAGE}" | head -n1)"
      other_content="$(echo "${OMGF_USAGE}" | tail -n+2)"
    fi
    echo "${first_line}"
    echo
    shift_left=0
    # shellcheck disable=SC2004
    [[ ${COLUMNS} -gt 1 ]] && shift_left=5 && export MANWIDTH=$((COLUMNS+${shift_left}))
    # shellcheck disable=SC2005
    echo "${other_content}" | man --nj --nh -l - | sed "1,2d;/^[[:space:]]*$/d;\${d};s/^ \{${shift_left}\}//"
  }

  function gf_version {
    echo "OMGF ${OMGF_VERNUM}"
  }

  function what_now {
    stdout_verbose
    echo "***"
    git_repo_exists || {
      echo "* Not a git repository"
      echo "* - Run 'gf --init' to initialize OMGF"
      echo "***"
      return 3
    }
    local gcb
    gcb=$(current_branch)
    echo -n "* Current revision '${gcb}' is considered "
    case ${gcb} in
      HEAD)
        echo "elusive."
        echo "* - Checkout to existing branch, e.g. '${OMGF_DEV}'."
        ;;
      ${OMGF_MASTER}|${OMGF_STABLE_PREFIX}+([0-9]).+([0-9]))
        echo "a stable branch."
        echo "* - Run '${script_name}' to create hotfix or leave this branch."
        ;;
      ${OMGF_DEV})
        echo "a develop branch."
        echo "* - Make some bugfixes..."
        echo "* - Run 'omgf MYFEATURE' to create new feature."
        echo "* - Run 'omgf release' to release dev."
        ;;
      ${OMGF_RELEASE})
        echo "a release branch."
        echo "* - Make some bugfixes..."
        echo "* - Run '${script_name}' to merge only into '${OMGF_DEV}'."
        echo "* - Run 'omgf release' to create stable branch."
        ;;
      ${HOTFIX}-+([0-9]).+([0-9]).+([0-9]))
        echo "a hotfix branch."
        echo "* - Do some hotfixes..."
        echo "* - Run '${script_name}' to merge hotfix into stable branch."
        ;;
      *)
        echo "feature branch."
        echo "* - Develop current feature..."
        echo "* - Run '${script_name}' to merge it into '${OMGF_DEV}'."
    esac
    if ! git_status_empty 2>/dev/null; then
      echo "*"
      echo "* - Local changes detected; see 'git status' for more info"
    fi
    echo "***"
    stdout_silent
  }

  # variables
  local line script_name master stash conform yes verbose dry what_now color pos_x pos_y init request is_stdin gf_branch major minor patch stashed
  what_now=0
  dry=0
  stashed=0
  verbose=0
  yes=0
  script_name="omgf"

  #TODO: dissolve
  major=0
  minor=0
  patch=0
  master=v0.0
  ###

  color=auto
  pos_x=1
  pos_y=1
  [ -t 0 ]
  is_stdin=$?

  # process options
  # shellcheck disable=SC2223
  # shellcheck disable=SC2048
  if ! line=$(
    IFS=" " getopt -n "${0}" \
           -o chinrsvVwy\? \
           -l conform,color::,colour::,help,init,dry-run,request,stash,verbose,version,what-now,yes \
           -- "${*}"
  )
  then gf_usage; return 2; fi
  eval set -- "${line}"

  # load user options
  stash=0
  conform=0
  init=0
  request=0
  while [ $# -gt 0 ]; do
    case ${1} in
     -c|--conform) conform=1; shift ;;
     --color|--colour) shift; setcolor "${1}" || { gf_usage; return 2; }; shift ;;
     -s|--stash) stash=1; shift ;;
     -h|-\?|--help) gf_usage; return ;;
     -i|--init) init=1; conform=1; shift ;;
     -n|--dry-run) dry=1; shift ;;
     -r|--request) request=1; shift ;;
     -v|--verbose) verbose=1; shift ;;
     -V|--version) gf_version; return ;;
     -w|--what-now) what_now=1; shift ;;
     -y|--yes) yes=1; shift ;;
      --) shift; break ;;
      *-) echo "${script_name}: Unrecognized option '${1}'" >&2; gf_usage; return 2 ;;
       *) break ;;
    esac
  done

  shopt -s nocasematch

  # constants
  # TODO ${OMGF_}{HOTFIX,RELEASE,FEATURE} ?
  local -r \
    RED=1 \
    GREEN=2 \
    BLUE=4 \
    GITHUB="github.com" \
    BITBUCKET="bitbucket.org" \
    HOTFIX="hotfix" \
    FEATURE="feature" \
    PULL="pull" \
    PUSH="push" \
    CHANGELOG_KEYWORDS=(Added Changed Deprecated Removed Fixed Security)
  local -r \
    REFSHEADS="refs/heads" \
    DONE="$(colorize "  ok  " ${GREEN})" \
    FAIL="$(colorize " fail " ${RED})" \
    SKIP="$(colorize " skip " ${BLUE})"

  # proceed params
  local KEYWORD NAME par_kw par_name arg_count
  KEYWORD="${1:-}"
  NAME="${2:-}"
  par_kw=
  par_name=
  arg_count=$#

  # silent output by default
  stdout_silent

  [[ ${dry} == 1 ]] \
    && exit

  [[ ${what_now} == 1 ]] \
    && what_now \
    && exit

  gf_validate "${@}"

  [[ ${init} == 1 ]] \
    && git_stash_pop \
    && exit

  gf_process "${@}"
  git_stash_pop

}

main "$@"
