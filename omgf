#!/usr/bin/env bash

shopt -s extglob
# exit when any command fails
#set -e
# treat unset variables as error
set -u

# shellcheck disable=SC2223
: ${OMGF_DATAPATH:=.}
# shellcheck disable=SC2223
: ${OMGF_CHANGELOG:=CHANGELOG.md}
# shellcheck disable=SC2223
: ${OMGF_VERFILE:=VERSION}
# shellcheck disable=SC2223
: ${OMGF_DEV:=dev}
# shellcheck disable=SC2223
: ${OMGF_RELEASE:=release}
# shellcheck disable=SC2223
: ${OMGF_MASTER:=master}
# shellcheck disable=SC2223
: ${OMGF_PROD:=prod}
# shellcheck disable=SC2223
: ${OMGF_ORIGIN:=origin}
# shellcheck disable=SC2223
: ${OMGF_UPSTREAM:=${OMGF_ORIGIN}}
# shellcheck disable=SC2223
: ${OMGF_CHANGELOG_HEADER:=# Change Log
All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](http://keepachangelog.com/)
and this project adheres to [Semantic Versioning](http://semver.org/).}
# shellcheck disable=SC2223
: ${OMGF_STABLE_PREFIX:=v}
: ${COLUMNS:=$(tput cols)}
: ${LINES:=$(tput lines)}

function main {

  function msg_start {
    [[ ${verbose} -eq 0 ]] \
      && return
    if stdoutpipe || [[ ${COLUMNS} -lt 41 ]]; then
      echo -n "${1}" \
        && return
    fi
    echo -n "[ "
    save_cursor_position
    echo " ....  ] ${1}"
  }

  function msg_end {
    [[ ${verbose} -eq 0 ]] \
      && return
    if stdoutpipe || [[ ${COLUMNS} -lt 41 ]]; then
      echo " [ ${1} ]" \
        && return
    fi
    set_cursor_position
    echo "${1}"
  }

  function stdout_silent {
    return
    [[ ${verbose} == 0 ]] && exec 5<&1 && exec 1>/dev/null
  }

  function stdout_verbose {
    return
    [[ ${verbose} == 0 ]] && exec 1<&5
  }

  function err {
    echo "${1}" >&2
    exit "${2:-1}"
  }

  function setcolor {
    local c
    c=${1:-always}
    case ${c} in
      always|never|auto)
        color=${c}
        return 0
      ;;
    esac
    return 2
  }

  function stdoutpipe {
    readlink /proc/$$/fd/1 | grep -q "^pipe:"
  }

  function colorize {
    [[ ${color} == never ]] \
      && echo -n "${1}" \
      && return
    [[ ${color} == auto ]] \
      && stdoutpipe \
      && echo -n "${1}" \
      && return
    tput setaf "${2:-${GREEN}}"
    echo -n "${1}"
    tput sgr0
  }

  function clear_stdin {
    while read -r -t 0; do read -r; done
  }

  function save_cursor_position {
    local curpos oldstty
    curpos="1;1"
    exec < /dev/tty
    oldstty=$(stty -g)
    stty raw -echo min 0
    echo -en "\033[6n" >/dev/tty
    # shellcheck disable=SC2162
    read -d"R" curpos </dev/tty
    stty "${oldstty}"
    pos_x=$( echo "${curpos#??}" | cut -d";" -f1 )
    pos_y=$( echo "${curpos#??}" | cut -d";" -f2 )
  }

  function set_cursor_position {
    [[ "${pos_x}" == "${LINES}" ]] && : $(( pos_x-- ))
    tput cup $(( pos_x-1 )) $(( pos_y-1 ))
  }

  function strtolower {
    echo "${1}" | tr '[:upper:]' '[:lower:]'
  }

  function trim {
    echo "${1}" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//'
  }

  function confirm {
    [[ ${yes} == 1 ]] && return
    if [[ ${is_stdin} == 0 ]]; then
      stdout_verbose
      echo -n "${1:-"Are you sure?"} [YES/No] "
      save_cursor_position
      clear_stdin
      read -r
      [[ -z "${REPLY}" ]] && set_cursor_position && echo "yes"
      stdout_silent
    else
      read -r
    fi
    [[ "${REPLY,,}" =~ ^y(es)?$ || -z "${REPLY}" ]] && return 0
    [[ "${REPLY,,}" =~ ^no?$ ]] && exit
    confirm "Type"
  }

  function git_status_empty {
    [[ -z "$(git status --porcelain)" ]]
  }

  # make git return only error to stderr
  function gch {
    local out
    out="$(git checkout "${@}" 2>&1)" \
      || err "${out}"
  }

  function git_init {
    local out
    out="$(git init "${@}" 2>&1)" \
      || err "${out}"
  }

  function git_add {
    local out
    out="$(git add "${@}" 2>&1)" \
      || err "${out}"
  }

  function git_commit {
    local out
    out="$(git commit "${@}" 2>&1)" \
      || err "${out}"
  }

  function git_stash {
    local out
    out="$(git stash "${@}" 2>&1)" \
      || err "${out}"
  }

  # make git return only error to stderr
  function git_fetch {
    msg_start "Fetching ${*}"
    local out
    out="$(git fetch --update-head-ok "${@}" 2>&1)" \
      || err "${out}"
    msg_end "${DONE}"
  }

  function git_tag {
    local out
    out="$(git tag "${@}" 2>&1)" \
      || err "${out}" >&2
  }

  function git_merge_nocommit {
    env GIT_EDITOR=: git merge --no-commit "${@}" >/dev/null 2>&1
  }

  function git_merge {
    local out
    out="$(env GIT_EDITOR=: git merge "${@}" 2>&1)" \
      || err "${out}"
  }

  function git_show {
    local out
    out="$(git show "${@}" 2>&1)" \
      || err "${out}"
    echo "${out}"
  }

  function git_show_exists {
    git show "${@}" >/dev/null 2>&1
  }

  function git_rev_list {
    git rev-list -n1 "${1}"
  }

  function git_merge_base {
    git merge-base "${1}" "${2}"
  }

  function git_branch {
    local out
    out="$(git branch "${@}" 2>&1)" \
      || err "${out}"
  }

  function git_branch_merged {
    local out
    out="$(git branch --merged "${@}" 2>&1)" \
      || err "${out}"
    echo "${out}"
  }

  function git_push {
    msg_start "Pushing to remote"
    local out
    out="$(git push "${@}" 2>&1)" \
      || err "${out}"
    msg_end "${DONE}"
  }

  function create_branch {
    msg_start "Creating branch '${1}'"
    local out
    out="$(gch -b "${1}")" \
      || err "${out}"
    msg_end "${DONE}"
  }

  function validate_branch {
    local_branch_exists "${1}" \
      && return
    [[ ${conform} == 0 ]] \
      && err "Branch '${1}' not found." 3
    msg_start "Creating branch '${1}'"
    # shellcheck disable=SC2015
    remote_branch_exists "${1}" \
      && git_branch "${1}" "${OMGF_ORIGIN}/${1}" \
      || git_branch "${1}" "${OMGF_MASTER}"
    msg_end "${DONE}"
  }

  function local_branch_exists {
    git rev-parse --verify "${1}" >/dev/null 2>&1
  }

  function remote_branch_exists {
    git ls-remote --heads "${OMGF_ORIGIN}" 2>/dev/null | grep -q "${REFSHEADS}/${1}\$"
  }

  function git_tag_exists {
    git tag | grep -q "^${1}"
  }

  function has_tag {
    [[ -n $(git tag --merged "${1}" -l "${2}") ]]
  }

  function git_repo_exists {
    [[ -d .git ]]
  }

  function validate_git_remote {
    git config remote."${OMGF_ORIGIN}".url >/dev/null \
      || err "Remote url for '${OMGF_ORIGIN}' not found."
  }

  function git_current_branch {
    git rev-parse --abbrev-ref HEAD
  }

  function stash_files {
    msg_start "Stashing files"
    git_status_empty \
      && msg_end "${SKIP}" \
      && return
    git_add -A
    git_stash push
    stashed=1
    msg_end "${DONE}"
  }

  function unstash_files {
    [[ ${stashed} == 0 ]] \
      && return 0
    msg_start "Unstashing files"
    git_stash pop
    msg_end "${DONE}"
  }

  function is_merged_to {
    git_branch_merged "${2}" | grep -q "${1}"
  }

  # merge upwards preserving conflicts
  # merge downwards ignoring VERSION and CHANGELOG conflicts
  # upwards: feature->dev->release->master, hotfix->master
  # downwards: master->release->dev
  function merge_fromto {
    local stream
    stream='upwards'
    [[ "${1}" == "${OMGF_MASTER}" || "${2}" == "${OMGF_DEV}" ]] \
      && stream='downwards'
    msg_start "Merging '${1}' to '${2}' (${stream})."
    is_merged_to "${1}" "${2}" \
      && msg_end "${SKIP}" \
      && return
    gch "${2}"
    git_merge_stream "${1}" "${stream}"
    msg_end "${DONE}"
  }

  function git_merge_stream {
    [[ "${2}" == "upwards" ]] \
      && git_merge --no-ff "${1}" \
      && return
    git_merge_nocommit --no-ff --no-commit "${1}"
    gch --ours "${OMGF_VERFILE}"
    #TODO: resolve changelog automatically
    #gch --ours "${OMGF_CHANGELOG}"
    git_add .
    git_merge --continue
  }

  function delete_remote_branch {
    msg_start "Deleting remote branch '${1}'"
    ! remote_branch_exists "${1}" \
      && msg_end "${SKIP}" \
      && return
    #TODO: used to be:
    #git push "${OMGF_ORIGIN}" ":${REFSHEADS}/${1}" 2>&1
    git push -d "${OMGF_ORIGIN}" "${1}"
    msg_end "${DONE}"
  }

  function delete_branch {
    [[ "$(git_current_branch)" == "${1}" ]] \
      && err "Unable to delete checked branch"
    delete_remote_branch "${1}"
    msg_start "Deleting local branch '${1}'"
    git_branch -d "${1}"
    msg_end "${DONE}"
  }

  function load_version {
    local branch ver
    branch=${1:-$(git_current_branch)}
    ver=$(git_show "${branch}:${OMGF_VERFILE}")
    [[ "${ver}" =~ ^[0-9]+\.[0-9]+\.[0-9]$ ]] \
      || err "Invalid version format on branch '${branch}'." 4
    echo "${ver}"
  }

  function master_last_change {
    git cherry -v "${OMGF_DEV}" "${OMGF_MASTER}" | tail -n1 | cut -d" " -f2
  }

  # ${1} filepath
  # ${2} default content
  function init_file {
    [[ -f "${1}" && -n "${1}" ]] \
      && return
    [[ ${conform} == 0 ]] \
      && err "Missing or empty file '${1}'." 3
    echo "${2}" > "${1}" \
      || exit 1
  }

  function parse_version {
    echo "${1}" | sed -n 's/.*\([0-9]\+\.[0-9]\+\.[0-9]\+\).*/\1/p'
  }

  function version_gt {
    ! version_lte "${1}" "${2}"
  }

  function version_lte {
    [[ "${1}" == "$(echo -e "${1}\n${2}" | sort -V | head -n1)" ]]
  }

  function validate_requirements {
    local bash_minv git_minv bash_ver git_ver
    bash_minv=3.2
    git_minv=1.8.0
    bash_ver="$(parse_version "$(bash --version 2>/dev/null)")"
    git_ver="$(parse_version "$(git --version 2>/dev/null)")"
    version_lte "${bash_minv}" "${bash_ver}" \
      || err "OMGF requires Bash version ${bash_minv} or later (you have ${bash_ver:-no Bash installed})."
    version_lte "${git_minv}" "${git_ver}" \
      || err "OMGF requires Git version ${git_minv} or later (you have ${git_ver:-no Git installed})."
  }

  # 1) validate repository existence
  # 2) validate repository consistency:
  # - at least one commit
  # - master branch
  function validate_repository {
    git_repo_exists \
      && local_branch_exists "${OMGF_MASTER}" \
      && return
    [[ ${init} == 0 ]] \
      && ! git_repo_exists \
      && err "Git repository not found." 3
    [[ ${init} == 0 ]] \
      && ! local_branch_exists "${OMGF_MASTER}" \
      && err "Missing commit on '${OMGF_MASTER}'." 3
    [[ "$(ls -A .)" && "${stash}" == 0 ]] \
      && err "Folder is not empty." 3
    msg_start "Initializing repository"
    local out
    git_init .
    init_file "${OMGF_VERFILE}" "0.0.0"
    init_file "${OMGF_CHANGELOG}" "${OMGF_CHANGELOG_HEADER}"
    git_add "${OMGF_VERFILE}" "${OMGF_CHANGELOG}"
    git_commit -m "Init files"
    msg_end "${DONE}"
  }

  function validate_hotfix_tag {
    local ver
    ver=$(load_version "${OMGF_MASTER}")
    has_tag "${OMGF_MASTER}" "${ver}" \
      && return
    [[ ${conform} == 0 ]] \
      && err "Missing hotfix tag '${ver}' on branch '${OMGF_MASTER}'." 3
    git_tag "${ver}" "${OMGF_MASTER}"
  }

  function validate_release_tag {
    local ver verr base
    ver=$(load_version "${OMGF_MASTER}")
    verr=${ver%.*}.0
    base=$(git_merge_base "${OMGF_MASTER}" "${OMGF_RELEASE}")
    has_tag "${OMGF_MASTER}" "${verr}" \
      && [[ $(git_rev_list "tags/${verr}") == "${base}" ]] \
      && return
    has_tag "${OMGF_MASTER}" "${verr}" \
      && [[ $(git_rev_list "tags/${verr}") != "${base}" ]] \
      && err "Invalid release tag ${verr} commit." 4
    [[ ${conform} == 0 ]] \
      && err "Missing release tag '${verr}' on branch '${OMGF_MASTER}'." 3
    git_tag "${verr}" "${OMGF_MASTER}"
  }

  # 1) validate ${OMGF_DEV} branch
  # 2) validate ${OMGF_DEV} is up to date with master
  function validate_merged_to {
    is_merged_to "${1}" "${2}" \
      && return
    [[ ${conform} == 0 ]] \
      && err "Branch '${1}' is not merged to '${2}'." 3
    merge_fromto "${1}" "${2}"
  }

  function validate_release_branch {
    local verm verr
    verm=$(load_version "${OMGF_MASTER}")
    verr=$(load_version "${OMGF_RELEASE}")
    version_gt "${verr%.*}" "${verm%.*}" \
      && validate_merged_to "${OMGF_RELEASE}" "${OMGF_DEV}" \
      && return
    [[ "${verr%.*}" == "${verm%.*}" ]] \
      && validate_attached "${OMGF_RELEASE}" "${OMGF_MASTER}" \
      && return
    [[ ${conform} == 0 ]] \
      && err "Branch '${OMGF_RELEASE}' version is lower than '${OMGF_MASTER}'." 3
    update_version "${OMGF_RELEASE}" "$(increment_version "${verm}" minor)"
  }

  function validate_attached {
    [[ $(git_rev_list "heads/${1}") == $(git_rev_list "heads/${2}") ]] \
      || err "Branch '${1}' is detached from '${2}'." 4
  }

  function update_version {
    local gcb
    gcb=$(git_current_branch)
    msg_start "Updating version number"
    gch "${1}"
    echo "${2}" > "${OMGF_VERFILE}"
    git_add "${OMGF_VERFILE}"
    git_commit -am "Update version number"
    msg_end "${DONE}"
    gch "${gcb}"
  }

  function validate_dev_branch {
    local verd verr
    verr=$(load_version "${OMGF_RELEASE}")
    verd=$(load_version "${OMGF_DEV}")
    version_gt "${verd%.*}" "${verr%.*}" \
      && return
    [[ ${conform} == 0 ]] \
      && err "Branch '${OMGF_DEV}' version is lower or equal to '${OMGF_RELEASE}'." 3
    update_version "${OMGF_DEV}" "$(increment_version "${verr}" minor)"
  }

  # validate git status
  function validate_status_empty {
    git_status_empty \
      && return
    [[ ${stash} == 1 ]] \
      && stash_files \
      && return
    err "Uncommitted changes." 5
  }

  function validate_changelog {
    git_show_exists "${1}:${OMGF_CHANGELOG}" \
      && [[ -n $(git_show "${1}:${OMGF_CHANGELOG}") ]] \
      && return
    local gcb
    gcb=$(git_current_branch)
    gch "${1}"
    init_file "${OMGF_CHANGELOG}" "${OMGF_CHANGELOG_HEADER}"
    git_add .
    git_commit -am "Add changelog file"
    gch "${gcb}"
  }

  function validate_verfile {
    git_show_exists "${1}:${OMGF_VERFILE}" \
      && return
    local gcb
    gcb=$(git_current_branch)
    gch "${1}"
    init_file "${OMGF_VERFILE}" "0.0.0"
    git_add "${OMGF_VERFILE}"
    git_commit -am "Add version file"
    gch "${gcb}"
  }

  function gf_validate {
    local gcb=${OMGF_DEV}
    validate_requirements
    local_branch_exists "${OMGF_MASTER}" \
      && gcb=$(git_current_branch)
    validate_repository
    validate_status_empty
    # branches and control files existence
    validate_branch "${OMGF_MASTER}"
    validate_branch "${OMGF_RELEASE}"
    validate_branch "${OMGF_DEV}"
    validate_verfile "${OMGF_MASTER}"
    validate_verfile "${OMGF_RELEASE}"
    validate_verfile "${OMGF_DEV}"
    validate_changelog "${OMGF_MASTER}"
    validate_changelog "${OMGF_RELEASE}"
    validate_changelog "${OMGF_DEV}"
    # gitflow dependencies
    validate_prod_branch
    validate_merged_to "${OMGF_MASTER}" "${OMGF_RELEASE}"
    validate_merged_to "${OMGF_MASTER}" "${OMGF_DEV}"
    validate_release_branch
    validate_dev_branch
    # Validate release tag before hotfix tag
    # to prevent confusion if no hotfix exists.
    # E.g. "Missing hotfix tag 0.1.0" is confusing.
    validate_release_tag
    validate_hotfix_tag
    gch "${gcb}"
  }

  function prod_name {
    local ver
    ver="${1:-$(load_version "${OMGF_MASTER}")}"
    echo "${OMGF_PROD}-${ver%%.*}"
  }

  function validate_prod_branch {
    local prod
    prod=$(prod_name)
    validate_branch "${prod}"
    [[ $(git_rev_list "heads/${prod}") == $(git_rev_list "heads/${OMGF_MASTER}") ]] \
      && return
    [[ ${conform} == 0 ]] \
      && err "Branch '${prod}' is behind '${OMGF_MASTER}'." 3
    gch "${prod}"
    git_merge "${OMGF_MASTER}"
  }

  function gf_process {
    [[ ${#} -gt 2 ]] \
      && err "Too many arguments." 2
    local gcb
    gcb=$(git_current_branch)
    kw=${1:-"${gcb%%-*}"}
    name=${2:-"$(whoami)"}
    git check-ref-format "${REFSHEADS}/${name}" \
      || err "Invalid branch name format '${name}'." 2
    case "${1:-"${kw,,}"}" in
      ${HOTFIX}|${OMGF_MASTER}|${OMGF_PROD})
        [[ "${gcb%%-*}" == "${HOTFIX}" ]] \
          && hotfix_release \
          && return
        confirm_checkout_if_exists "${HOTFIX}-${name}" \
          && return
        hotfix_create "${HOTFIX}-${name}"
        ;;
      ${FEATURE}|${OMGF_DEV})
        [[ "${gcb%%-*}" == "${FEATURE}" ]] \
          && feature_merge \
          && return
        confirm_checkout_if_exists "${FEATURE}-${name}" \
          && return
        feature_create "${FEATURE}-${name}"
        ;;
      ${OMGF_RELEASE})
        [[ "${gcb}" == "${OMGF_DEV}" ]] \
          && release_dev \
          && return
        [[ "${gcb}" == "${OMGF_RELEASE}" ]] \
          && release_release \
          && return
        confirm_checkout_if_exists "${OMGF_RELEASE}" \
          && return
        err "Expected branch not found." 1
        ;;
      ${PULL})
        gf_pull
        ;;
      ${PUSH})
        gf_push
        ;;
      *)
        err "Unknown keyword or branch." 2
        ;;
    esac
  }

  function confirm_checkout_if_exists {
    local_branch_exists "${1}" \
      || return 1
    confirm "* Checkout to branch '${1}'?"
    gch "${1}"
  }

  function release_dev {
    confirm "* Release '${OMGF_DEV}' branch?"
    #TODO: technically this check is irrelevant
    is_merged_to "${OMGF_RELEASE}" "${OMGF_DEV}" \
      || err 'Branch already released.' 6
    update_changelog_header
    git_commit -am "Add changelog header"
    merge_fromto "${OMGF_DEV}" "${OMGF_RELEASE}"
    merge_fromto "${OMGF_RELEASE}" "${OMGF_DEV}"
    increment_version "$(load_version)" minor > "${OMGF_VERFILE}"
    git_commit -am "Increment minor version"
  }

  function feature_create {
    local feature_name
    feature_name="${1}"
    confirm_checkout_if_exists "${feature_name}" \
      && return
    confirm "* Create branch '${feature_name}' from branch '${OMGF_DEV}'?"
    create_branch "${feature_name}"
  }

  function hotfix_create {
    local gcb source
    gcb=$(git_current_branch)
    source=${OMGF_MASTER}
    [[ "${gcb%%-*}" == "${OMGF_PROD}" ]] \
      && source=${gcb}
    confirm "* Create hotfix '${1}' from '${source}'?"
    gch "${source}"
    create_branch "${1}"
  }

  function release_release {
    # shellcheck disable=SC2015
    [[ ${request} == 1 ]] \
      && confirm "* Request merge '${OMGF_RELEASE}' to '${OMGF_MASTER}'?" \
      || confirm "* Release '${OMGF_RELEASE}' branch to '${OMGF_MASTER}'?"
    is_merged_to "${OMGF_RELEASE}" "${OMGF_MASTER}" \
      && err 'Branch already released.' 6
    update_changelog_header
    git_commit -am "Update control files"
    merge_fromto "${OMGF_MASTER}" "${OMGF_RELEASE}"
    [[ ${request} == 1 ]] \
      && gf_request "${OMGF_MASTER}" \
      && return
    merge_fromto "${OMGF_RELEASE}" "${OMGF_MASTER}"
    msg_start "Updating branching structure"
    git_tag "$(load_version)"
    gch "${OMGF_RELEASE}"
    git_merge "${OMGF_MASTER}"
    local prod
    prod=$(prod_name)
    # shellcheck disable=SC2015
    local_branch_exists "${prod}" \
      && gch "${prod}" \
      && git_merge "${OMGF_MASTER}" \
      || git_branch "${prod}" "${OMGF_MASTER}"
    msg_end "${DONE}"
    merge_fromto "${OMGF_MASTER}" "${OMGF_DEV}"
    #merge_fromto "${OMGF_MASTER}" "${OMGF_RELEASE}"
  }

  function get_diff_url {
    local url
    url="$(trim_url "$(git config remote."${OMGF_ORIGIN}".url)")"
    case "${url}" in
      *"${GITHUB}"*)
        echo "https://${url}/compare/${1}...${2}"
        ;;
      *"${BITBUCKET}"*)
        echo "https://${url}/compare/${2}..${1}"
        ;;
      "")
        return
        ;;
      *)
        err "Unsupported git remote."
        ;;
    esac
  }

  function update_changelog_header {
    local header tmpfile diff_url prev_tag ver
    ver=$(load_version)
    msg_start "Updating changelog header"
    header="## [${ver}] - $(date "+%Y-%m-%d")"
    prev_tag="$(git tag | sort -V | tail -n1 )"
    diff_url="$(get_diff_url "${prev_tag}" "${ver}" )"
    [[ -n "${diff_url}" ]] \
      && diff_url="[${ver}]: ${diff_url}" \
      || diff_url="[${ver}]: ${prev_tag}..${ver}"
    tmpfile="$(mktemp)"
    gawk -v header="${header}" -v diff_url="${diff_url}" '
      BEGIN {
        writemsg=1
        writeurl=1
      }
      /^\[Unreleased\]/ { next }
      writemsg == 1 && /^## / {
        print header
        writemsg=0
        if($0 ~ "^## \\[?Unreleased\\]?") { next }
        print ""
      }
      writeurl == 1 && /^\[/ && ! /^\[Unreleased\]/ {
        print diff_url
        writeurl=0
      }
      {print}
      ENDFILE {
        if(writemsg==1) { print header }
        if(writeurl==1) { print ""; print diff_url }
      }
      ' "${OMGF_CHANGELOG}" > "${tmpfile}"
    cat "${tmpfile}" > "${OMGF_CHANGELOG}"
    msg_end "${DONE}"
  }

  function add_changelog_entry {
    local tmpfile diff_url
    tmpfile="$(mktemp)"
    diff_url="$(get_diff_url "${OMGF_MASTER}" "${OMGF_DEV}")"
    [[ -n "${diff_url}" ]] \
      && diff_url="[Unreleased]: ${diff_url}" \
      || diff_url="[Unreleased]: ${OMGF_MASTER}..${OMGF_DEV}"
    gawk -v keyword="${1}" -v next_keywords="${2}" -v message="${3}" -v diff_url="${diff_url}" '
      function print_unreleased () { print "## [Unreleased]" }
      function print_keyword () { print "### " keyword }
      function print_message () { print " - " message }
      BEGIN {
        writemsg=1
        unreleased=0
        writeurl=1
      }
      /^## \[?Unreleased\]?/ { unreleased=1 }
      writemsg == 1 && unreleased == 0 && /^## / && ! /^## \[?Unreleased\]?/ {
        print_unreleased()
        print_keyword()
        print_message()
        print ""
        writemsg=0
      }
      writemsg == 1 && $0 ~ "^## " next_keywords && ! /^## \[?Unreleased\]?/ {
        print_keyword()
        print_message()
        print ""
        writemsg=0
      }
      /^\[Unreleased\]/ { writeurl=0 }
      writeurl == 1 && /^\[/ {
        print diff_url
        writeurl=0
      }
      {print}
      writemsg == 1 && $0 == "### " keyword {
        print_message()
        writemsg=0
      }
      ENDFILE {
        if(writemsg == 1) {
          print ""
          if(unreleased == 0) { print_unreleased() }
          print_keyword()
          print_message()
        }
        if(writeurl==1) { print diff_url }
      }
    ' "${OMGF_CHANGELOG}" > "${tmpfile}"
    cat "${tmpfile}" > "${OMGF_CHANGELOG}"
  }

  function gf_update_changelog {
    local commits
    commits="$(git log "${2}".."$(git_current_branch)" --pretty=format:"*   %h %s")"
    stdout_verbose
    echo
    echo "***"
    echo "* Please enter the $(git_current_branch) description for ${OMGF_CHANGELOG}."
    echo "*"
    echo "* Keywords:"
    echo "*   $(echo "${CHANGELOG_KEYWORDS[@]}" | sed "s/ /, /g;s/${CHANGELOG_KEYWORDS[${1}]}/${CHANGELOG_KEYWORDS[${1}]} (default)/")"
    echo "*"
    echo "* Commits of '$(git_current_branch)':"
    echo "${commits}"
    echo "*"
    REPLY=
    if [[ ${is_stdin} == 0 ]]; then
      echo "Type \"Keyword: Message\", empty line to end:"
      clear_stdin
    fi
    local message keyword next_keywords i found
    while read -e -r message; do
      [[ -z "${message}" ]] && break
      history -s "${message}"
      keyword="$(trim "$(echo "${message}" | cut -sd':' -f1)")"
      next_keywords=
      found=0
      i=
      if [[ -n "${keyword}" ]]; then
        for i in "${!CHANGELOG_KEYWORDS[@]}"; do
          [[ "${CHANGELOG_KEYWORDS[i]}" != "${keyword}"* ]] && continue
          keyword="${CHANGELOG_KEYWORDS[i]}"
          found=1
          break
        done
        if [[ "${found}" == 0 ]]; then
          echo "'${keyword}' is not a valid keyword"
          continue
        fi
      else
        i=${1}
        keyword="${CHANGELOG_KEYWORDS[${i}]}"
      fi
      for ((index="${i}+1"; index < ${#CHANGELOG_KEYWORDS[@]}; index++)); do
        next_keywords="${next_keywords}|^### ${CHANGELOG_KEYWORDS[index]}"
      done
      [[ "${found}" == 1 ]] && message="$(echo "${message}" | cut -d':' -f2-)"
      add_changelog_entry "${keyword}" "${next_keywords}" "$(trim "${message}")"
    done
    stdout_silent
  }

  function feature_merge {
    local source
    source=$(git_current_branch)
    is_merged_to "${source}" "${OMGF_DEV}" \
      && err "Nothing to merge." 6
    # shellcheck disable=SC2015
    [[ ${request} == 1 ]] \
      && confirm "* Request merge '${source}' into '${OMGF_DEV}'?" \
      || confirm "* Merge '${source}' into '${OMGF_DEV}'?"
    merge_fromto "${OMGF_DEV}" "${source}"
    gf_update_changelog 0 "${OMGF_DEV}"
    git_add .
    git_commit -m "Update changelog"
    [[ ${request} == 1 ]] \
      && gf_request "${OMGF_DEV}"
    merge_fromto "${source}" "${OMGF_DEV}"
    delete_branch "${source}"
  }

  ### Increments the part of the string
  ## $1: version itself
  ## $2: number of part: major, minor, patch
  function increment_version {
    local major minor patch
    major=$(echo "${1}" | cut -d. -f1)
    minor=$(echo "${1}" | cut -d. -f2)
    patch=$(echo "${1}" | cut -d. -f3)
    case "${2}" in
      major)
        (( major ++ ))
        minor=0
        patch=0
        ;;
      minor)
        (( minor ++ ))
        patch=0
        ;;
      patch)
        (( patch ++ ))
        ;;
      *)
        err "Invalid version type."
    esac
    echo "${major}.${minor}.${patch}"
  }

  function hotfix_release {
    local source dest vers verd
    source=$(git_current_branch)
    dest=${OMGF_MASTER}
    vers=$(load_version "${source}")
    verd=$(load_version "${OMGF_MASTER}")
    [[ "${vers%%.*}" > "${verd%%.*}" ]] \
      && err "Hotfix version is greater than '${OMGF_MASTER}'." 4
    # shellcheck disable=SC2015
    [[ "${vers%%.*}" < "${verd%%.*}" ]] \
      && dest="$(prod_name "${vers}")" \
      && verd="$(load_version "${dest}")" \
      && confirm "* Obsolete major version. Merge to branch '${dest}'?" \
      || confirm "* Release the hotfix?"
    ! local_branch_exists "${dest}" \
      && err "Branch '${dest} not found." 4
    is_merged_to "${source}" "${dest}" \
      && err "Nothing to merge." 6
    msg_start "Updating control files"
    gf_update_changelog 4 "${dest}"
    increment_version "${verd}" patch > "${OMGF_VERFILE}"
    update_changelog_header
    git_commit -am "Update control files"
    msg_end "${DONE}"
    [[ ${request} == 1 ]] \
      && gf_request "${dest}" \
      && return
    merge_fromto "${source}" "${dest}"
    git_tag "$(load_version)"
    [[ "${dest}" == "${OMGF_MASTER}" ]] \
      && gch "${dest}" \
      && git_merge "${OMGF_MASTER}" \
      && merge_fromto "${OMGF_MASTER}" "${OMGF_RELEASE}" \
      && merge_fromto "${OMGF_MASTER}" "${OMGF_DEV}" \
      && merge_fromto "${OMGF_RELEASE}" "${OMGF_DEV}"
    delete_branch "${source}"
  }

  function gf_pull_branch {
    remote_branch_exists "${1}" \
      || return
    git_fetch "${OMGF_ORIGIN}" "${1}:${1}"
  }

  function gf_pull {
    validate_git_remote
    git_fetch --tags
    gf_pull_branch "${OMGF_DEV}"
    gf_pull_branch "${OMGF_MASTER}"
    gf_pull_branch "${OMGF_RELEASE}"
    local stable
    for stable in $(git_branch -r | grep 'origin/' | grep -o 'v[0-9]\+\.[0-9]\+'); do
      gf_pull_branch "${stable}"
    done
  }

  function gf_push {
    validate_git_remote
    git_push --tags
    git_push "${OMGF_ORIGIN}" "${OMGF_DEV}"
    git_push "${OMGF_ORIGIN}" "${OMGF_MASTER}"
    git_push "${OMGF_ORIGIN}" "${OMGF_RELEASE}"
    for stable in $(git_branch -r | grep 'origin/' | grep -o 'v[0-9]\+\.[0-9]\+'); do
      local_branch_exists "${stable}" \
        && git_push "${OMGF_ORIGIN}" "${stable}"
    done
  }

  function gf_request {
    validate_git_remote
    [[ "${OMGF_ORIGIN}" == "${OMGF_UPSTREAM}" ]] \
      || git_push "${OMGF_ORIGIN}" "${1}"
    git_push "${OMGF_ORIGIN}" "${1}"
    gf_request_url "${1}"
  }

  function trim_url {
    local url
    url="${1#https://}"
    echo "${url}" | grep -q ":" \
      && url="${url#*@}" \
      && url="${url/://}" \
      && url="${url/.git/}"
    echo "${url}"
  }

  function gf_request_url {
    local url upstream_url to gcb
    to="${1:-${OMGF_DEV}}"
    url=$(trim_url "$(git config remote."${OMGF_ORIGIN}".url)")
    upstream_url="$(git config remote."${OMGF_UPSTREAM}".url)"
    upstream_url="$(trim_url "${upstream_url}")"
    gcb=$(git_current_branch)
    stdout_verbose
    echo -n "Pull request URL: "
    case "${url}" in
      *"${GITHUB}"*)
        # shellcheck disable=SC1003
        [[ "${url}" == "${upstream_url}" ]] \
          && echo "https://${url}/compare/${to}...${gcb}?expand=1" \
          || echo "https://${upstream_url}/compare/${to}...$(echo "${url}" | cut -d'/' -f2)%3A${gcb}?expand=1"
      ;;
      *"${BITBUCKET}"*)
        # shellcheck disable=SC1003
        [[ "${url}" == "${upstream_url}" ]] \
          && echo "https://${url}/compare/${gcb}..$(echo "${url}" | cut -d'/' -f2-3)%3A${to}" \
          || echo "https://${url}/compare/${gcb}..$(echo "${upstream_url}" | cut -d'/' -f2-3)%3A${to}"
      ;;
      *)
        err "Unsupported remote server name."
      ;;
    esac
    stdout_silent
  }

  function gf_usage {
    local usage_file shift_left first_line other_content
    if [[ -z "${OMGF_USAGE+x}" ]]; then
      usage_file="${OMGF_DATAPATH}/${script_name}.usage"
      [ -f "${usage_file}" ] \
        || err "Usage file not found"
      first_line="$(head -n1 "${usage_file}")"
      other_content="$(tail -n+2 "${usage_file}")"
    else
      first_line="$(echo "${OMGF_USAGE}" | head -n1)"
      other_content="$(echo "${OMGF_USAGE}" | tail -n+2)"
    fi
    echo "${first_line}"
    echo
    shift_left=0
    # shellcheck disable=SC2004
    [[ ${COLUMNS} -gt 1 ]] && shift_left=5 && export MANWIDTH=$((COLUMNS+${shift_left}))
    # shellcheck disable=SC2005
    echo "${other_content}" | man --nj --nh -l - | sed "1,2d;/^[[:space:]]*$/d;\${d};s/^ \{${shift_left}\}//"
  }

  function gf_version {
    [[ -n "${OMGF_VERNUM+x}" ]] \
      && echo "OMGF ${OMGF_VERNUM}" \
      && return
    ver=$(<"${OMGF_DATAPATH}/VERSION")
    echo -n "OMGF ${ver}"
  }

  function what_now {
    stdout_verbose
    echo "***"
    echo -n "* Current revision is considered "
    case $(git_current_branch) in
      HEAD)
        echo "elusive."
        echo "* - Checkout to existing branch, e.g. '${OMGF_DEV}'."
        ;;
      ${OMGF_MASTER}|${OMGF_STABLE_PREFIX}+([0-9]).+([0-9]))
        echo "a stable branch."
        echo "* - Run '${script_name}' to create hotfix or leave this branch."
        ;;
      ${OMGF_DEV})
        echo "a develop branch."
        echo "* - Make some bugfixes..."
        echo "* - Run 'omgf MYFEATURE' to create new feature."
        echo "* - Run 'omgf release' to release dev."
        ;;
      ${OMGF_RELEASE})
        echo "a release branch."
        echo "* - Make some bugfixes..."
        echo "* - Run '${script_name}' to merge only into '${OMGF_DEV}'."
        echo "* - Run 'omgf release' to create stable branch."
        ;;
      ${HOTFIX}-+([0-9]).+([0-9]).+([0-9]))
        echo "a hotfix branch."
        echo "* - Do some hotfixes..."
        echo "* - Run '${script_name}' to merge hotfix into stable branch."
        ;;
      *)
        echo "feature branch."
        echo "* - Develop current feature..."
        echo "* - Run '${script_name}' to merge it into '${OMGF_DEV}'."
    esac
    if ! git_status_empty 2>/dev/null; then
      echo "*"
      echo "* - Local changes detected; see 'git status' for more info"
    fi
    echo "***"
    stdout_silent
  }

  # variables
  [ -t 0 ]
  declare is_stdin=${?}
  declare what_now=0
  declare dry=0
  declare stashed=0
  declare verbose=0
  declare yes=0
  declare script_name=omgf
  declare color=auto
  declare pos_x=1
  declare pos_y=1

  # process options
  # shellcheck disable=SC2223
  # shellcheck disable=SC2048
  if ! line=$(
    IFS=" " getopt -n "${0}" \
      -o chinrsvVwy\? \
      -l conform,color::,colour::,help,init,dry-run,request,stash,verbose,version,what-now,yes \
      -- "${@}"
  ); then gf_usage; return 2; fi
  eval set -- "${line}"

  # load user options
  stash=0
  conform=0
  init=0
  request=0
  while [[ ${#} -gt 0 ]]; do
    case ${1} in
     -c|--conform) conform=1; shift ;;
     --color|--colour) shift; setcolor "${1}" || { gf_usage; return 2; }; shift ;;
     -s|--stash) stash=1; shift ;;
     -h|-\?|--help) gf_usage; return ;;
     -i|--init) init=1; conform=1; shift ;;
     -n|--dry-run) dry=1; shift ;;
     -r|--request) request=1; shift ;;
     -v|--verbose) verbose=1; shift ;;
     -V|--version) gf_version; return ;;
     -w|--what-now) what_now=1; shift ;;
     -y|--yes) yes=1; shift ;;
      --) shift; break ;;
      *-) echo "${script_name}: Unrecognized option '${1}'" >&2; gf_usage; return 2 ;;
       *) break ;;
    esac
  done

  # system constants
  declare -r GREEN=2
  declare -r BLUE=4
  declare -r GITHUB="github.com"
  declare -r BITBUCKET="bitbucket.org"
  declare -r HOTFIX="hotfix"
  declare -r FEATURE="feature"
  declare -r PULL="pull"
  declare -r PUSH="push"
  declare -r CHANGELOG_KEYWORDS=(Added Changed Deprecated Removed Fixed Security)
  declare -r REFSHEADS="refs/heads"
  declare DONE
  DONE="$(colorize " done " ${GREEN})"
  declare SKIP
  SKIP="$(colorize " pass " ${BLUE})"

  stdout_silent
  gf_validate "${@}"

  [[ ${dry} == 1 ]] \
    && unstash_files \
    && exit

  [[ ${what_now} == 1 ]] \
    && what_now \
    && exit

  [[ ${init} == 1 ]] \
    && unstash_files \
    && exit

  gf_process "${@}"
  unstash_files

}

main "${@}"
