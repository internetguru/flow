#!/usr/bin/env butt

function take {
  cd "${curdir}" \
    && rm -rf "${1}" \
    && mkdir "${1}" \
    && cd "${1}" \
    || exit 2
}

# make git return only error to stderr
function gch {
  local out
  out="$(git checkout "$@" 2>&1)" \
    || err "${out}"
}

function git_current_branch {
  git rev-parse --abbrev-ref HEAD
}

function gsp {
  git status --porcelain
}

function gref {
  ref="$(git show-ref)"
}

function checkInitRefs {
  assert_equal "$(echo "${ref}" | wc -l)" 5
  assert_contains "${ref}" "refs/heads/dev"
  assert_contains "${ref}" "refs/heads/${1:-main}"
  assert_contains "${ref}" "refs/heads/staging"
  assert_contains "${ref}" "refs/heads/prod-0"
  assert_contains "${ref}" "refs/tags/0.0.0"
}

function checkInitFiles {
  assert_equal "$(git show dev:VERSION)" "0.1.0"
  assert_equal "$(git show ${1:-main}:VERSION)" "0.0.0"
  assert_equal "$(git show staging:VERSION)" "0.0.0"
  assert_equal "$(git show prod-0:VERSION)" "0.0.0"
  assert_equal "$(head -n1 CHANGELOG.md)" "# Change Log"
}

function grep_log {
  git log --no-color --oneline --all | grep --quiet "${1}"
}

function load_log {
  log="$(git log --no-color --oneline --decorate --all)"
  IFS=$'\n' read -d '' -r -a loglines <<< "${log}" || return 0
}

export OMGF_OPTIONS=""
export COLUMNS=30

#local i curdir ref log loglines chglog chgloglines
i=0
curdir="$(pwd)"
ref=
log=
loglines=()
chglog=
outlines=()

#######################################
## Integration
#######################################
# TODO test omgf help on macOs, now it is skipped due to issue https://github.com/InternetGuru/omgf/issues/66
: $((i++))
start "omgf help"
  take "${i}"
  debug "omgf --help"
  assert_equal "${status}" 0
  assert_startwith "${outlines[0]}" "Usage: omgf [-"
  assert_startwith "${outlines[1]}" "  -c, --conform"
  debug "omgf -n"
  assert_equal "${status}" 3
end
#######################################
: $((i++))
start "omgf --version shows version"
  take "${i}"
  debug "omgf --version"
  assert_equal "${status}" 0
  assert_startwith "${outlines[0]}" "OMGF "
  debug "omgf -n"
  assert_equal "${status}" 3
end
#######################################
: $((i++))
start "omgf -V shows version"
  take "${i}"
  debug "omgf -V"
  assert_equal "${status}" 0
  assert_startwith "${outlines[0]}" "OMGF "
  debug "omgf -n"
  assert_equal "${status}" 3
end
#######################################
# : $((i++))
# start "man omgf"
#   take "${i}"
#   debug "man 2>/dev/null omgf"
#   assert_equal "${status}" 0
#   assert_startwith "${outlines[0]}" "GF(1)"
#   debug "omgf -n"
#   assert_equal "${status}" 0
# end
#######################################
## Error codes
#######################################
: $((i++))
start "invalid option error code"
  take "${i}"
  debug "omgf --invalid-option"
  assert_equal "${status}" 2
  assert_startwith "${outlines[0]}" "Usage: omgf [-"
  debug "omgf -n"
  assert_equal "${status}" 3
end
#######################################
: $((i++))
start "missing git error code"
  take "${i}"
  debug "omgf"
  assert_equal "${status}" 3
  # shellcheck disable=SC2154
  assert_startwith "${errlines[0]}" "Git repository not found."
end
#######################################
: $((i++))
start "missing branch dev error code"
  take "${i}"
  { omgf -i \
    && gch main \
    && git branch -D dev
  } >/dev/null 2>&1
  debug "omgf"
  assert_equal "${status}" 3
  assert_startwith "${errlines[0]}" "Branch 'dev' not found."
end
#######################################
: $((i++))
start "missing VERSION file error code"
  take "${i}"
  { omgf -i \
    && rm VERSION \
    && git commit -am "delete VERSION file"
  } >/dev/null
  debug "omgf"
  assert_equal "${status}" 3
  assert_equal "${errlines[0]}" "Missing or empty file 'VERSION'."
end
#######################################
: $((i++))
start "dev is behind main error code"
  take "${i}"
  { omgf -i \
    && echo a > a \
    && git add a \
    && git commit -am "add file a" \
    && omgf staging --yes \
    && omgf staging --yes \
    && gch dev \
    && git reset --hard HEAD~1
  } >/dev/null
  debug "omgf -v"
  assert_equal "${status}" 3
  assert_startwith "${errlines[0]}" "Branch 'main' is not merged to 'dev'."
end
#######################################
: $((i++))
start "uncommitted changes error code"
  take "${i}"
  { omgf -i \
    && echo a > a
  } >/dev/null
  debug "omgf"
  assert_equal "${status}" 5
  assert_startwith "${errlines[0]}" "Uncommitted changes."
end
#######################################
: $((i++))
start "version change on dev"
  take "${i}"
  { omgf -i \
    && echo 1.0.0 > VERSION \
    && git commit -am "bump version" \
    && omgf --yes hotfix a \
    && echo a > a \
    && git add . \
    && git commit -am "fix a"
  } >/dev/null
  debug "echo '' | omgf --yes"
  assert_equal "${status}" 0
  load_log
  assert_contains "${log}" "(HEAD -> dev) Merge branch 'main' into dev"
  assert_contains "${log}" "(tag: 0.0.1, staging, prod-0, main) Merge branch 'hotfix-a' into main"
  assert_contains "${log}" "Merge branch 'main' into dev"
  assert_equal "$(git show main:VERSION)" "0.0.1"
  assert_equal "$(git show staging:VERSION)" "0.0.1"
  assert_equal "$(git show dev:VERSION)" "1.0.0"
  gref
  assert_equal "$(echo "${ref}" | grep /refs/heads/hotfix-a)" ""
  assert_equal "$(gsp)" ""
  debug "omgf -n"
  assert_equal "${status}" 0
end
#######################################
## Dry run
#######################################
: $((i++))
start "dry run"
  take "${i}"
  debug "omgf --dry-run"
  assert_equal "${status}" 3
  assert_startwith "${errlines[0]}" "Git repository not found."
end
#######################################
: $((i++))
start "dry run and invalid option"
  take "${i}"
  debug "omgf --dry-run --invalid-option"
  assert_equal "${status}" 2
  #assert_startwith "${outlines[0]}" "getopt: unknown"
  assert_startwith "${outlines[0]}" "Usage: omgf [-"
end
#######################################
## Init
#######################################
: $((i++))
start "init on empty folder"
  take "${i}"
  debug "omgf --init"
  assert_equal "${status}" 0
  checkInitFiles
  gref
  checkInitRefs
  assert_equal "$(gsp)" ""
  debug "omgf -n"
  assert_equal "${status}" 0
end
#######################################
: $((i++))
start "init on non-empty folder"
  take "${i}"
  { touch a \
    && touch b
  } >/dev/null
  debug "omgf --init"
  assert_equal "${status}" 3
  assert_startwith "${errlines[0]}" "Folder is not empty."
end
#######################################
: $((i++))
start "init on non-empty folder with stash"
  take "${i}"
  { touch a \
    && touch b \
    && echo b > .gitignore
  } >/dev/null
  debug "omgf --init --stash"
  assert_equal "${status}" 0
  checkInitFiles
  gref
  checkInitRefs
  assert_equal "$(gsp | wc -l)" 2
  debug "omgf -n"
  assert_equal "${status}" 5
end
#######################################
: $((i++))
start "init on existing repo with commits"
  take "${i}"
  { git init \
    && echo a > a \
    && git add . \
    && git commit -am "first commit.."
  } >/dev/null
  debug "omgf -v --init"
  assert_equal "${status}" 0
  checkInitFiles master
  gref
  checkInitRefs master
  assert_equal "$(gsp)" ""
  debug "omgf -n"
  assert_equal "${status}" 0
end
#######################################
: $((i++))
start "init on existing repo uncommitted"
  take "${i}"
  { git init \
    && echo a > a
  } >/dev/null
  debug "omgf -v --init"
  assert_equal "${status}" 3
  assert_startwith "${errlines[0]}" "Folder is not empty."
end
#######################################
: $((i++))
start "init on existing repo without commits with --stash"
  take "${i}"
  { git init \
    && echo a > a
  } >/dev/null
  debug "omgf -v --init --stash"
  assert_equal "${status}" 0
  checkInitFiles master
  gref
  checkInitRefs master
  assert_equal "$(gsp)" "A  a"
  debug "omgf -n"
  assert_equal "${status}" 5
end
#######################################
## Conform
#######################################
: $((i++))
start "conform on empty folder"
  take "${i}"
  debug "yes no | omgf --conform"
  assert_equal "${status}" 3
  assert_startwith "${errlines[0]}" "Git repository not found."
end
#######################################
: $((i++))
start "conform on existing repo without commits"
  take "${i}"
  { git init \
    && echo a > a
  } >/dev/null
  debug "omgf --conform"
  assert_equal "${status}" 3
  assert_startwith "${errlines[0]}" "Missing initial commit."
end
#######################################
: $((i++))
start "init on existing repo with commits and --stash"
  take "${i}"
  { git init \
    && echo a > a \
    && git add . \
    && git commit -am "first commit" \
    && echo b > b
  } >/dev/null
  debug "omgf --init --stash --yes"
  assert_equal "${status}" 0
  checkInitFiles master
  gref
  #checkInitRefs
  assert_equal "$(git_current_branch)" "dev"
  assert_equal "$(gsp | wc -l)" 1
  debug "omgf -n"
  assert_equal "${status}" 5
end
#######################################
: $((i++))
start "conform on existing repo with commits and --stash"
  take "${i}"
  { git init \
    && echo a > a \
    && git add . \
    && git commit -am "first commit" \
    && echo b > b
  } >/dev/null
  debug "omgf --conform --stash --yes"
  assert_equal "${status}" 0
  checkInitFiles master
  gref
  #checkInitRefs
  assert_equal "$(git_current_branch)" "hotfix-$(whoami)"
  assert_equal "$(gsp | wc -l)" 1
  debug "omgf -n"
  assert_equal "${status}" 5
end
#######################################
## Feature
#######################################
: $((i++))
start "create feature"
  take "${i}"
  { omgf --init; } >/dev/null
  debug "omgf -v --yes"
  assert_equal "${status}" 0
  gref
  assert_contains "${ref}" "refs/heads/feature-$(whoami)"
  assert_equal "$(git_current_branch)" "feature-$(whoami)"
  debug "omgf -n"
  assert_equal "${status}" 6
end
#######################################
: $((i++))
start "create feature with uncommited changes and --stash"
  take "${i}"
  { omgf --init \
    && echo a > a
  } >/dev/null
  debug "omgf -v --yes --stash feature myfeature"
  assert_equal "${status}" 0
  assert_contains "${outlines[0]}" "Stashing files"
  assert_equal "$(git_current_branch)" "feature-myfeature"
  assert_equal "$(gsp)" "A  a"
  debug "omgf -n"
  assert_equal "${status}" 5
end
#######################################
: $((i++))
start "merge feature"
  take "${i}"
  { omgf --init \
    && omgf --yes feature myfeature \
    && echo a > a \
    && git add . \
    && git commit -am "add feature 1"
  } >/dev/null
  debug "echo 'feature1' | omgf --yes"
  assert_equal "${status}" 0
  load_log
  assert_contains "${log}" "Update changelog"
  assert_contains "${loglines[0]}" "(HEAD -> dev) Merge branch 'feature-myfeature' into dev"
  gref
  assert_equal "$(echo "${ref}" | grep /refs/heads/feature-myfeature)" ""
  assert_equal "$(git show dev:CHANGELOG.md | head -8 | tail -1)" "### Added"
  assert_equal "$(git show dev:CHANGELOG.md | head -9 | tail -1)" " - feature1"
  assert_equal "$(gsp)" ""
  debug "omgf -n"
  assert_equal "${status}" 0
end
#######################################
: $((i++))
start "merge empty feature"
  take "${i}"
  { omgf --init \
    && omgf --yes feature myfeature
  } >/dev/null
  debug "omgf -v --yes"
  assert_equal "${status}" 6
  assert_startwith "${errlines[0]}" "Nothing to merge."
end
#######################################
: $((i++))
start "merge feature with uncommitted changes and --stash"
  take "${i}"
  { omgf --init \
    && omgf --yes feature myfeature \
    && echo a > a \
    && git add . \
    && git commit -am "add feature 1" \
    && echo b > b
  } >/dev/null
  debug "echo 'feature1' | omgf --yes --stash"
  assert_equal "${status}" 0
  #assert_contains "${outlines[0]}" "Stashing files"
  load_log
  assert_contains "${log}" "Update changelog"
  assert_contains "${loglines[0]}" "(HEAD -> dev) Merge branch 'feature-myfeature' into dev"
  gref
  assert_equal "$(echo "${ref}" | grep /refs/heads/feature-myfeature)" ""
  assert_equal "$(gsp)" "A  b"
  debug "omgf -n"
  assert_equal "${status}" 5
end
#######################################
# start "merge feature with --request"
#   { omgf --init \
#     && omgf --yes myfeature \
#     && echo a > a \
#     && git add . \
#     && git commit -am "add feature 1"
#   } >/dev/null
#   debug "echo 'feature1' | omgf --yes --request"
# fi
#######################################
## RELEASE
#######################################
: $((i++))
start "create staging"
  take "${i}"
  { omgf --init \
    && echo a > a \
    && git add . \
    && git commit -m "add file a"
  } >/dev/null
  debug "omgf -v --yes staging"
  assert_equal "${status}" 0
  assert_equal "$(git show dev:VERSION)" "0.2.0"
  assert_equal "$(git show staging:VERSION)" "0.1.0"
  assert_equal "$(git show dev:CHANGELOG.md | head -6 | tail -1)" "## [0.1.0] - $(date "+%Y-%m-%d")"
  assert_equal "$(git show staging:CHANGELOG.md | head -6 | tail -1)" "## [0.1.0] - $(date "+%Y-%m-%d")"
  gref
  assert_contains "${ref}" "refs/heads/staging"
  assert_equal "$(gsp)" ""
  debug "omgf -n"
  assert_equal "${status}" 0
end
#######################################
# : $((i++))
# start "try create two stagings"
#   take "${i}"
#   { omgf --init \
#     && echo a > a \
#     && git add . \
#     && git commit -m "add file a" \
#     && omgf --yes staging \
#     && gch dev \
#     && echo b > b \
#     && git add . \
#     && git commit -m "add file b"
#   } >/dev/null 2>&1
#   debug "omgf -v --yes staging"
#   assert_equal "${status}" 0
#   assert_equal "$(git_current_branch)" "staging"
#   assert_equal "$(gsp)" ""
#   debug "omgf -n"
#   assert_equal "${status}" 0
# end
#######################################
: $((i++))
start "staging with uncommited changes and --stash"
  take "${i}"
  { omgf --init \
    && echo a > a \
    && git add . \
    && git commit -m "add file a" \
    && echo b > b
  } >/dev/null
  debug "omgf -v --yes --stash staging"
  assert_equal "${status}" 0
  assert_contains "${outlines[0]}" "Stashing files"
  gref
  assert_contains "${ref}" "refs/heads/staging"
  assert_equal "$(gsp)" "A  b"
  debug "omgf -n"
  assert_equal "${status}" 5
end
#######################################
: $((i++))
start "merge staging"
  take "${i}"
  { omgf --init \
    && echo a > a \
    && git add . \
    && git commit -m "add file a" \
    && omgf --yes staging
  } >/dev/null
  debug "omgf -v --yes staging"
  assert_equal "${status}" 0
  assert_equal "$(git show dev:VERSION)" "0.2.0"
  assert_equal "$(git show staging:VERSION)" "0.1.0"
  assert_equal "$(git show main:VERSION)" "0.1.0"
  load_log
  assert_contains "${log}" "(HEAD -> dev) Merge branch 'main' into dev"
  assert_contains "${log}" "(tag: 0.1.0, staging, prod-0, main) Merge branch 'staging' into main"
  assert_contains "${log}" "Increment minor version"
  gref
  assert_equal "$(echo "${ref}" | grep /refs/heads/staging)" ""
  assert_equal "$(gsp)" ""
  debug "omgf -n"
  assert_equal "${status}" 0
end
#######################################
: $((i++))
start "invalid version number"
  take "${i}"
  { omgf --init \
    && echo 0.0.0 > VERSION \
    && git commit -am "version"
  } >/dev/null 2>&1
  debug "omgf"
  assert_equal "${status}" 3
  assert_startwith "${errlines[0]}" "Branch 'dev' version is lower or equal to 'staging'."
end
#######################################
: $((i++))
start "invalid version number --conform"
  take "${i}"
  { omgf --init \
    && gch staging \
    && echo 1.0.0 > VERSION \
    && git commit -am "version"
  } >/dev/null 2>&1
  debug "omgf --conform --yes"
  assert_equal "${status}" 0
  assert_equal "$(cat VERSION)" "1.1.0"
  debug "omgf -n"
  assert_equal "${status}" 0
end
#######################################
: $((i++))
start "unmerged changes on staging"
  take "${i}"
  { omgf --init \
    && gch staging \
    && touch a \
    && git add . \
    && git commit -am "version"
  } >/dev/null
  debug "omgf --yes staging"
  assert_equal "${status}" 4
  assert_startwith "${errlines[0]}" "Branch 'staging' is detached from 'main'."
end
#######################################
# : $((i++))
# start "merge staging with --request"
#  take "${i}"
#   { omgf --init \
#     && omgf --yes
#   } >/dev/null
#   debug "omgf -v --yes --request"
# fi
#######################################
## HOTFIX
#######################################
: $((i++))
start "hotfix main"
  take "${i}"
  { omgf -i; } >/dev/null
  debug "omgf -v --yes hotfix myhotfix"
  assert_equal "${status}" 0
  assert_equal "$(git_current_branch)" "hotfix-myhotfix"
  assert_equal "$(gsp)" ""
  debug "omgf -n"
  assert_equal "${status}" 6
end
#######################################
# : $((i++))
# start "hotfix prod"
#   take "${i}"
#   { omgf -i; } >/dev/null 2>&1
#   debug "omgf --yes hotfix myhotfix"
#   assert_equal "${status}" 0
#   assert_equal "$(git_current_branch)" "hotfix-myhotfix"
#   assert_equal "$(gsp)" ""
#   debug "omgf -n"
#   assert_equal "${status}" 0
# end
#######################################
# : $((i++))
# start "hotfix stable by branch name"
#   take "${i}"
#   { omgf -i \
#    && echo a > a \
#    && git add . \
#    && git commit -m "add file a" \
#    && omgf --yes staging \
#    && omgf --yes staging
#   } >/dev/null 2>&1
#   debug "omgf -v --yes hotfix v0.0"
#   assert_equal "${status}" 0
#   load_log
#   assert_equal "$(git_current_branch)" "hotfix-${user}"
#   assert_equal "$(gsp)" ""
#   debug "omgf -n"
#   assert_equal "${status}" 0
# end
#######################################
: $((i++))
start "merge main hotfix"
  take "${i}"
  { omgf -i \
   && omgf --yes hotfix myhotfix \
   && echo a > a \
   && git add . \
   && git commit -m "add file a";
  } >/dev/null
  debug "echo '' | omgf --yes"
  assert_equal "${status}" 0
  load_log
  assert_contains "${loglines[0]}" "(HEAD -> dev) Merge branch 'main' into dev"
  assert_contains "${log}" "(tag: 0.0.1, staging, prod-0, main) Merge branch 'hotfix-myhotfix' into main"
  assert_equal "$(git show dev:VERSION)" "0.1.0"
  assert_equal "$(git show staging:VERSION)" "0.0.1"
  assert_equal "$(git show main:VERSION)" "0.0.1"
  gref
  assert_equal "$(echo "${ref}" | grep /refs/heads/hotfix-myhotfix)" ""
  assert_equal "$(gsp)" ""
  debug "omgf -n"
  assert_equal "${status}" 0
end
#######################################
: $((i++))
start "merge hotfix with unmerged staging"
  take "${i}"
  { omgf -i \
   && omgf --yes staging \
   && omgf --yes hotfix myhotfix \
   && echo b > b \
   && git add . \
   && git commit -m "add file b"
  } >/dev/null
  # assume conflicts
  debug "echo '' | omgf --yes"
  assert_equal "${status}" 0
  load_log
  assert_contains "${loglines[0]}" "(HEAD -> dev) Merge branch 'staging' into dev"
  assert_contains "${log}" "(tag: 0.0.1, prod-0, main) Merge branch 'hotfix-myhotfix' into main"
  assert_equal "$(git show dev:VERSION)" "0.2.0"
  assert_equal "$(git show staging:VERSION)" "0.1.0"
  assert_equal "$(git show main:VERSION)" "0.0.1"
  gref
  assert_equal "$(echo "${ref}" | grep /refs/heads/hotfix-myhotfix)" ""
  assert_equal "$(gsp)" ""
  debug "omgf -n"
  assert_equal "${status}" 0
  debug "omgf -n"
  assert_equal "${status}" 0
end
