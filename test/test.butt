#!/usr/bin/env butt

function take {
  cd "${curdir}" \
    && rm -rf "${1}" \
    && mkdir "${1}" \
    && cd "${1}" \
    || exit 2
}

# make git return only error to stderr
function gch {
  local out
  out="$(git checkout "$@" 2>&1)" \
    || err "${out}"
}

function git_current_branch {
  git rev-parse --abbrev-ref HEAD
}

function gsp {
  git status --porcelain
}

function gref {
  ref="$(git show-ref)"
}

function arrowToComma {
  echo "${1// ->/,}"
}

function checkInitRefs {
  assert_equal "$(echo "${ref}" | wc -l)" 4
  assert_contains "${ref}" "refs/heads/dev"
  assert_contains "${ref}" "refs/heads/master"
  assert_contains "${ref}" "refs/heads/release"
  assert_contains "${ref}" "refs/tags/v0.0.0"
}

function checkInitFiles {
  assert_equal "$(git show dev:VERSION)" "0.1.0"
  assert_equal "$(git show master:VERSION)" "0.0.0"
  assert_equal "$(git show release:VERSION)" "0.0.0"
  assert_equal "$(head -n1 CHANGELOG.md)" "# Change Log"
}

function grep_log {
  git log --no-color --oneline --all | grep --quiet "${1}"
}

function load_log {
  log="$(git log --no-color --oneline --decorate --all)"
  IFS=$'\n' read -d '' -r -a loglines <<< "${log}" || return 0
}

function load_changelog {
  chglog="$(git show "${1:-HEAD}":CHANGELOG.md)"
  IFS=$'\n' read -d '' -r -a chgloglines <<< "${chglog}" || return 0
}

export OMGF_OPTIONS=""
export COLUMNS=30

#local i curdir ref log loglines chglog chgloglines
i=0
curdir="$(pwd)"
ref=
log=
loglines=()
chglog=
chgloglines=()
outlines=()
user="$(echo "${USER}" | tr '[:upper:]' '[:lower:]')"

#######################################
## Integration
#######################################
# TODO test omgf help on macOs, now it is skipped due to issue https://github.com/InternetGuru/omgf/issues/66
: $((i++))
start "omgf help"
  take "${i}"
  debug "omgf --help 2>/dev/null"
  assert_equal "${status}" 0
  assert_startwith "${outlines[0]}" "Usage: omgf [-"
  assert_startwith "${outlines[1]}" "  -c, --conform"
end
#######################################
: $((i++))
start "omgf --version shows version"
  take "${i}"
  debug "omgf --version"
  assert_equal "${status}" 0
  assert_startwith "${outlines[0]}" "omgf "
end
#######################################
: $((i++))
start "omgf -V shows version"
  take "${i}"
  debug "omgf -V"
  assert_equal "${status}" 0
  assert_startwith "${outlines[0]}" "omgf "
end
#######################################
# : $((i++))
# start "man omgf"
#   take "${i}"
#   debug "man 2>/dev/null omgf"
#   assert_equal "${status}" 0
#   assert_startwith "${outlines[0]}" "GF(1)"
# end
#######################################
## Error codes
#######################################
: $((i++))
start "invalid option error code"
  take "${i}"
  debug "omgf --invalid-option"
  assert_equal "${status}" 2
  assert_startwith "${outlines[0]}" "Usage: omgf [-"
end
#######################################
: $((i++))
start "missing git error code"
  take "${i}"
  debug "omgf"
  assert_equal "${status}" 3
  # shellcheck disable=SC2154
  assert_startwith "${errlines[0]}" "omgf[error]: Git repository does not exist"
end
#######################################
: $((i++))
start "missing branch dev error code"
  take "${i}"
  { omgf -i \
    && gch master \
    && git branch -D dev
  } >/dev/null 2>&1
  debug "omgf"
  assert_equal "${status}" 3
  assert_startwith "${errlines[0]}" "omgf[error]: Missing branch 'dev'"
end
#######################################
: $((i++))
start "missing VERSION file error code"
  take "${i}"
  { omgf -i \
    && rm VERSION \
    && git commit -am "delete VERSION file"
  } >/dev/null
  debug "omgf"
  assert_equal "${status}" 3
  assert_equal "${errlines[0]}" "omgf[error]: Missing or empty file 'VERSION'"
end
#######################################
: $((i++))
start "dev is behind master error code"
  take "${i}"
  { omgf -i \
    && echo a > a \
    && git add a \
    && git commit -am "add file a" \
    && omgf release --yes \
    && omgf release --yes \
    && git reset --hard HEAD~1
  } >/dev/null
  debug "omgf -v"
  assert_equal "${status}" 3
  assert_startwith "${errlines[0]}" "omgf[error]: Branch 'master' is not merged with 'dev'"
end
#######################################
: $((i++))
start "uncommited changes error code"
  take "${i}"
  { omgf -i \
    && echo a > a
  } >/dev/null
  debug "omgf"
  assert_equal "${status}" 4
  assert_startwith "${errlines[0]}" "omgf[error]: Uncommitted changes"
end
#######################################
: $((i++))
start "version change on dev"
  take "${i}"
  { omgf -i \
    && echo 1.0.0 > VERSION \
    && git commit -am "bump version" \
    && omgf --yes hotfix a \
    && echo aa >> CHANGELOG.md \
    && git commit -am "fix changelog"
  } >/dev/null
  debug "echo '' | omgf --yes"
  assert_equal "${status}" 0
  load_log
  assert_contains "${log}" "(tag: v0.0.1, master)"
  assert_contains "${log}" "Merge branch 'master' into release"
  assert_contains "${log}" "Merge branch 'master' into dev"
  assert_equal "$(git show master:VERSION)" "0.0.1"
  assert_equal "$(git show release:VERSION)" "0.0.1"
  assert_equal "$(git show dev:VERSION)" "1.0.0"
  gref
  assert_equal "$(echo "${ref}" | grep /refs/heads/hotfix-a)" ""
  assert_equal "$(gsp)" ""
end
#######################################
## Dry run
#######################################
: $((i++))
start "dry run"
  take "${i}"
  debug "omgf --dry-run"
  assert_equal "${status}" 0
end
#######################################
: $((i++))
start "dry run and invalid option"
  take "${i}"
  debug "omgf --dry-run --invalid-option"
  assert_equal "${status}" 2
  #assert_startwith "${outlines[0]}" "getopt: unknown"
  assert_startwith "${outlines[0]}" "Usage: omgf [-"
end
#######################################
## Init
#######################################
: $((i++))
start "init on empty folder"
  take "${i}"
  debug "omgf -v --init"
  assert_equal "${status}" 0
  checkInitFiles
  gref
  checkInitRefs
  assert_equal "$(gsp)" ""
end
#######################################
: $((i++))
start "init on non-empty folder"
  take "${i}"
  { echo a > a \
    && echo b > b \
    && echo test > .gitignore
  } >/dev/null
  debug "omgf -v --init"
  assert_equal "${status}" 0
  checkInitFiles
  gref
  checkInitRefs
  assert_equal "$(gsp)" ""
end
#######################################
: $((i++))
start "init on existing repo with commits"
  take "${i}"
  { git init \
    && echo a > a \
    && git add . \
    && git commit -am "first commit.."
  } >/dev/null
  debug "omgf -v --init"
  assert_equal "${status}" 0
  checkInitFiles
  gref
  checkInitRefs
  assert_equal "$(gsp)" ""
end
#######################################
: $((i++))
start "init on existing repo without commits"
  take "${i}"
  { git init \
    && echo a > a
  } >/dev/null
  debug "omgf -v --init"
  assert_equal "${status}" 0
  checkInitFiles
  gref
  checkInitRefs
  assert_equal "$(gsp)" ""
end
#######################################
: $((i++))
start "init on existing repo with commits and --force"
  take "${i}"
  { git init \
    && echo a > a \
    && git add . \
    && git commit -am "first commit" \
    && echo b > b
  } >/dev/null
  debug "omgf -v --init --force"
  assert_equal "${status}" 0
  checkInitFiles
  gref
  checkInitRefs
  assert_equal "$(gsp | wc -l)" 1
end
#######################################
## Conform
#######################################
: $((i++))
start "conform on empty folder"
  take "${i}"
  debug "yes no | omgf --conform"
  assert_equal "${status}" 0
  checkInitFiles
  gref
  checkInitRefs
  assert_equal "$(gsp)" ""
end
#######################################
: $((i++))
start "conform on non-empty folder"
  take "${i}"
  { echo a > a \
    && echo b > b \
    && echo test > .gitignore
  } >/dev/null
  debug "yes no | omgf --conform"
  assert_equal "${status}" 0
  checkInitFiles
  gref
  checkInitRefs
  assert_equal "$(gsp)" ""
end
#######################################
: $((i++))
start "conform on existing repo with commits"
  take "${i}"
  { git init \
    && echo a > a \
    && git add . \
    && git commit -am "first commit.."
  } >/dev/null
  debug "yes no | omgf --conform"
  assert_equal "${status}" 0
  checkInitFiles
  gref
  checkInitRefs
  assert_equal "$(gsp)" ""
end
#######################################
: $((i++))
start "conform on existing repo without commits"
  take "${i}"
  { git init \
    && echo a > a
  } >/dev/null
  debug "yes no | omgf --conform"
  assert_equal "${status}" 0
  checkInitFiles
  gref
  checkInitRefs
  assert_equal "$(gsp)" ""
end
#######################################
: $((i++))
start "conform on existing repo with commits and --force"
  take "${i}"
  { git init \
    && echo a > a \
    && git add . \
    && git commit -am "first commit" \
    && echo b > b
  } >/dev/null
  debug "yes no | omgf --conform --force"
  assert_equal "${status}" 0
  checkInitFiles
  gref
  checkInitRefs
  assert_equal "$(gsp | wc -l)" 1
end
#######################################
## Feature
#######################################
: $((i++))
start "create feature"
  take "${i}"
  { omgf --init; } >/dev/null
  debug "omgf -v --yes myfeature"
  assert_equal "${status}" 0
  assert_contains "${outlines[0]}" "Creating branch 'feature-myfeature'"
  gref
  assert_contains "${ref}" "refs/heads/feature-myfeature"
  assert_equal "$(git_current_branch)" "feature-myfeature"
end
#######################################
: $((i++))
start "create feature with uncommited changes and --force"
  take "${i}"
  { omgf --init \
    && echo a > a
  } >/dev/null
  debug "omgf -v --yes --force myfeature"
  assert_equal "${status}" 0
  assert_contains "${outlines[0]}" "Stashing files"
  assert_equal "$(git_current_branch)" "feature-myfeature"
  assert_equal "$(gsp)" "A  a"
end
#######################################
: $((i++))
start "merge feature"
  take "${i}"
  { omgf --init \
    && omgf --yes myfeature \
    && echo a > a \
    && git add . \
    && git commit -am "add feature 1"
  } >/dev/null
  debug "echo 'feature1' | omgf --yes"
  assert_equal "${status}" 0
  load_log
  assert_contains "${log}" "Update CHANGELOG.md"
  assert_contains "$(arrowToComma "${loglines[0]}")" "(HEAD, dev) Merge branch 'feature-myfeature' into dev"
  gref
  assert_equal "$(echo "${ref}" | grep /refs/heads/feature-myfeature)" ""
  load_changelog
  assert_contains "${chglog}" "## Added"
  assert_contains "${chglog}" " - feature1"
  assert_equal "$(gsp)" ""
end
#######################################
: $((i++))
start "merge empty feature"
  take "${i}"
  { omgf --init \
    && omgf --yes myfeature
  } >/dev/null
  debug "omgf -v --yes"
  assert_equal "${status}" 1
  assert_startwith "${errlines[0]}" "omgf[error]: Nothing to merge"
end
#######################################
: $((i++))
start "merge feature with uncommited changes and --force"
  take "${i}"
  { omgf --init \
    && omgf --yes myfeature \
    && echo a > a \
    && git add . \
    && git commit -am "add feature 1" \
    && echo b > b
  } >/dev/null
  debug "echo 'feature1' | omgf --yes --force"
  assert_equal "${status}" 0
  #assert_contains "${outlines[0]}" "Stashing files"
  load_log
  assert_contains "${log}" "Update CHANGELOG.md"
  assert_contains "$(arrowToComma "${loglines[0]}")" "(HEAD, dev) Merge branch 'feature-myfeature' into dev"
  gref
  assert_equal "$(echo "${ref}" | grep /refs/heads/feature-myfeature)" ""
  assert_equal "$(gsp)" "A  b"
end
#######################################
# start "merge feature with --request"
#   { omgf --init \
#     && omgf --yes myfeature \
#     && echo a > a \
#     && git add . \
#     && git commit -am "add feature 1"
#   } >/dev/null
#   debug "echo 'feature1' | omgf --yes --request"
# fi
#######################################
## RELEASE
#######################################
: $((i++))
start "create release"
  take "${i}"
  { omgf --init \
    && echo a > a \
    && git add . \
    && git commit -m "add file a"
  } >/dev/null
  debug "omgf -v --yes release"
  assert_equal "${status}" 0
  load_changelog "dev"
  assert_equal "${chgloglines[4]:-}" "## [0.1.0] - $(date "+%Y-%m-%d")"
  assert_equal "$(cat VERSION)" "0.1.0"
  load_changelog
  assert_equal "${chgloglines[4]:-}" ""
  gref
  assert_contains "${ref}" "refs/heads/release"
  assert_equal "$(gsp)" ""
end
#######################################
: $((i++))
start "try create two releases"
  take "${i}"
  { omgf --init \
    && echo a > a \
    && git add . \
    && git commit -m "add file a" \
    && omgf --yes release \
    && gch dev \
    && echo b > b \
    && git add . \
    && git commit -m "add file b"
  } >/dev/null 2>&1
  debug "omgf -v --yes release"
  assert_equal "${status}" 0
  assert_equal "$(git_current_branch)" "release"
  assert_equal "$(gsp)" ""
end
#######################################
: $((i++))
start "release with uncommited changes and --force"
  take "${i}"
  { omgf --init \
    && echo a > a \
    && git add . \
    && git commit -m "add file a" \
    && echo b > b
  } >/dev/null
  debug "omgf -v --yes --force release"
  assert_equal "${status}" 0
  assert_contains "${outlines[0]}" "Stashing files"
  gref
  assert_contains "${ref}" "refs/heads/release"
  assert_equal "$(gsp)" "A  b"
end
#######################################
: $((i++))
start "merge release"
  take "${i}"
  { omgf --init \
    && echo a > a \
    && git add . \
    && git commit -m "add file a" \
    && omgf --yes release
  } >/dev/null
  debug "omgf -v --yes release"
  assert_equal "${status}" 0
  load_log
  assert_contains "$(arrowToComma "${log}")" "(HEAD, dev) Merge branch 'release' into dev"
  gref
  assert_equal "$(echo "${ref}" | grep /refs/heads/release)" ""
  assert_equal "$(gsp)" ""
end
#######################################
#TODO
# : $((i++))
# start "invalid version number"
#   take "${i}"
#   { omgf --init \
#     && echo a > a \
#     && git add . \
#     && git commit -m "add file a" \
#     && omgf --yes release \
#     && gch dev \
#     && echo 1.0.0 > VERSION \
#     && git commit -am "bump dev major VERSION" \
#     && gch release \
#     && echo 2.0.0 > VERSION \
#     && git commit -am "bump release major VERSION"
#   } >/dev/null 2>&1
#   debug "omgf -v --yes release"
#   assert_equal "${status}" 5
#   assert_contains "$(gsp)" "UU VERSION"
# end
#######################################
: $((i++))
start "merge release with uncommited changes and --force"
  take "${i}"
  { omgf --init \
    && echo a > a \
    && git add . \
    && git commit -m "add file a" \
    && omgf --yes release \
    && echo b > b
  } >/dev/null
  debug "omgf -v --yes --force release"
  assert_equal "${status}" 0
  assert_contains "${outlines[0]}" "Stashing files"
  load_log
  assert_contains "${loglines[0]}" "Merge branch 'release'"
  gref
  assert_equal "$(git show dev:VERSION)" "0.2.0"
  assert_equal "$(git show release:VERSION)" "0.1.0"
  assert_equal "$(git show master:VERSION)" "0.1.0"
  assert_equal "$(git_current_branch)" "dev"
  assert_equal "$(gsp)" "A  b"
end
#######################################
# : $((i++))
# start "merge release with --request"
#  take "${i}"
#   { omgf --init \
#     && omgf --yes
#   } >/dev/null
#   debug "omgf -v --yes --request"
# fi
#######################################
## HOTFIX
#######################################
: $((i++))
start "hotfix master"
  take "${i}"
  { omgf -i; } >/dev/null
  debug "omgf -v --yes hotfix myhotfix"
  assert_equal "${status}" 0
  assert_equal "$(git_current_branch)" "hotfix-myhotfix"
  assert_equal "$(gsp)" ""
end
#######################################
: $((i++))
start "hotfix stable"
  take "${i}"
  { omgf -i \
   && echo a > a \
   && git add . \
   && git commit -m "add file a" \
   && omgf --yes release \
   && omgf --yes release \
   && gch v0.0.0
  } >/dev/null 2>&1
  debug "omgf -v --yes myhotfix"
  assert_equal "${status}" 0
  assert_equal "$(git_current_branch)" "hotfix-myhotfix"
  assert_equal "$(gsp)" ""
end
#######################################
: $((i++))
start "hotfix master by branch name"
  take "${i}"
  { omgf -i; } >/dev/null
  debug "omgf -v --yes hotfix v0.0"
  assert_equal "${status}" 0
  load_log
  assert_equal "$(git_current_branch)" "hotfix-${user}"
  assert_equal "$(gsp)" ""
end
#######################################
: $((i++))
start "hotfix stable by branch name"
  take "${i}"
  { omgf -i \
   && echo a > a \
   && git add . \
   && git commit -m "add file a" \
   && omgf --yes release \
   && omgf --yes release
  } >/dev/null 2>&1
  debug "omgf -v --yes hotfix v0.0"
  assert_equal "${status}" 0
  load_log
  assert_equal "$(git_current_branch)" "hotfix-${user}"
  assert_equal "$(gsp)" ""
end
#######################################
: $((i++))
start "merge master hotfix"
  take "${i}"
  { omgf -i \
   && omgf --yes hotfix myhotfix \
   && echo a > a \
   && git add . \
   && git commit -m "add file a";
  } >/dev/null
  debug "echo '' | omgf --yes"
  assert_equal "${status}" 0
  load_log
  assert_contains "${log}" "tag: v0.0.1"
  assert_contains "${loglines[0]}" "(HEAD -> dev) Merge branch 'master' into dev"
  assert_equal "$(git show dev:VERSION)" "0.1.0"
  assert_equal "$(git show release:VERSION)" "0.0.1"
  gref
  assert_equal "$(echo "${ref}" | grep /refs/heads/hotfix-myhotfix)" ""
  assert_equal "$(gsp)" ""
end
#######################################
: $((i++))
start "merge hotfix (merged release)"
  take "${i}"
  { omgf -i \
   && echo a > a \
   && git add . \
   && git commit -m "add file a" \
   && omgf --yes hotfix myhotfix \
   && echo b > b \
   && git add . \
   && git commit -m "add file b"
  } >/dev/null
  # assume conflicts
  debug "echo '' | omgf --yes"
  assert_equal "${status}" 0
  load_log
  assert_contains "${log}" "(tag: v0.0.1, master)"
  assert_contains "${log}" "Merge branch 'master' into release"
  assert_contains "${log}" "Merge branch 'master' into dev"
  assert_equal "$(git show master:VERSION)" "0.0.1"
  assert_equal "$(git show release:VERSION)" "0.0.1"
  assert_equal "$(git show dev:VERSION)" "0.1.0"
  gref
  assert_equal "$(echo "${ref}" | grep /refs/heads/hotfix-myhotfix)" ""
  assert_equal "$(gsp)" ""
end
#######################################
: $((i++))
start "merge hotfix (unmerged release)"
  take "${i}"
  { omgf -i \
   && echo a > a \
   && git add . \
   && git commit -m "add file a" \
   && omgf --yes release \
   && omgf --yes hotfix myhotfix \
   && echo b > b \
   && git add . \
   && git commit -m "add file b"
  } >/dev/null
  # assume conflicts
  debug "echo '' | omgf --yes"
  assert_equal "${status}" 0
  load_log
  assert_contains "${log}" "(tag: v0.0.1, master)"
  assert_contains "${log}" "Merge branch 'master' into release"
  assert_contains "${log}" "Merge branch 'master' into dev"
  assert_equal "$(git show master:VERSION)" "0.0.1"
  assert_equal "$(git show release:VERSION)" "0.1.0"
  assert_equal "$(git show dev:VERSION)" "0.2.0"
  gref
  assert_equal "$(echo "${ref}" | grep /refs/heads/hotfix-myhotfix)" ""
  assert_equal "$(gsp)" ""
end
