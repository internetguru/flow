#!/usr/bin/env bash

shopt -s extglob
set -u

LINES=${LINES:-$(tput lines)}
COLUMNS=${COLUMNS:-$(tput cols)}

FLOW_DATAPATH=${FLOW_DATAPATH:-$(dirname "${BASH_SOURCE[0]}")}
FLOW_USAGE=${FLOW_USAGE:-}
FLOW_VERNUM=${FLOW_VERNUM:-}
FLOW_VERFILE=${FLOW_VERFILE:-${FLOW_DATAPATH}/VERSION}

REPO_CHANGELOG=${REPO_CHANGELOG:-CHANGELOG.md}
REPO_VERFILE=${REPO_VERFILE:-VERSION}
REPO_DEV=${REPO_DEV:-dev}
REPO_STAGING=${REPO_STAGING:-staging}
REPO_STABLE=${REPO_STABLE:-main}
REPO_PROD=${REPO_PROD:-prod}
REPO_ORIGIN=${REPO_ORIGIN:-origin}
REPO_UPSTREAM=${REPO_UPSTREAM:-${REPO_ORIGIN}}
REPO_changelog_stamp=${REPO_changelog_stamp:-'# Change Log
All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](http://keepachangelog.com/)
and this project adheres to [Semantic Versioning](http://semver.org/).'}

main() {

  msg_start() {
    [[ ${VERBOSE} -eq 0 ]] \
      && return
    if stdoutpipe || [[ ${COLUMNS} -lt 41 ]]; then
      echo -n "${1}" \
        && return
    fi
    echo -n '[ '
    save_cursor_position
    echo " ....  ] ${1}"
  }

  msg_done() {
    msg_end "$(colorize ' done ' "${GREEN}")"
  }

  msg_pass() {
    msg_end "$(colorize ' pass ' "${BLUE}")"
  }

  msg_end() {
    [[ ${VERBOSE} -eq 0 ]] \
      && return
    if stdoutpipe || [[ ${COLUMNS} -lt 41 ]]; then
      echo " [ ${1} ]" \
        && return
    fi
    set_cursor_position
    echo "${1}"
  }

  err() {
    echo "${SCRIPT_NAME}: ${1:-Generic error}" >&2
    [[ "${2:-}" == 2 ]] \
      && echo "${USAGE}" >&2
    [[ "${2:-}" == 3 ]] \
      && echo "This appears to be fixable with the --conform option." >&2
    [[ "${2:-}" == 5 ]] \
      && echo "Commit/stash your changes or use the --stash option." >&2
    exit "${2:-1}"
  }

  setcolor() {
    local c=${1:-always}
    case ${c} in
      always|never|auto)
        COLOR=${c}
        return 0
      ;;
    esac
    err 'Unknown color value' 2
  }

  stdoutpipe() {
    readlink /proc/$$/fd/1 | grep -q '^pipe:'
  }

  colorize() {
    [[ ${COLOR} == never ]] \
      && echo -n "${1}" \
      && return
    [[ ${COLOR} == auto ]] \
      && stdoutpipe \
      && echo -n "${1}" \
      && return
    tput setaf "${2:-${GREEN}}"
    echo -n "${1}"
    tput sgr0
  }

  clear_stdin() {
    while read -r -t 0; do read -r; done
  }

  save_cursor_position() {
    local curpos oldstty
    curpos='1;1'
    exec < /dev/tty
    oldstty=$(stty -g)
    stty raw -echo min 0
    echo -en '\033[6n' >/dev/tty
    # shellcheck disable=SC2162
    read -d'R' curpos </dev/tty
    stty "${oldstty}"
    POSX=$( echo "${curpos#??}" | cut -d';' -f1 )
    POSY=$( echo "${curpos#??}" | cut -d';' -f2 )
  }

  set_cursor_position() {
    [[ "${POSX}" == "${LINES}" ]] && : $(( POSX -- ))
    tput cup $(( POSX - 1 )) $(( POSY - 1 ))
  }

  confirm() {
    [[ ${DRYRUN} == 1 ]] \
      && exit
    [[ ${YES} == 1 ]] \
      && return
    if [[ ${ISSTDIN} == 0 ]]; then
      echo -n "${1:-'Are you sure?'} [YES/No] "
      save_cursor_position
      clear_stdin
      read -r
      [[ -z "${REPLY}" ]] && set_cursor_position && echo 'yes'
    else
      read -r
    fi
    [[ "${REPLY,,}" =~ ^y(es)?$ || -z "${REPLY}" ]] \
      && return
    [[ "${REPLY,,}" =~ ^no?$ ]] \
      && exit
    confirm 'Type'
  }

  git_status_empty() {
    [[ -z "$(git status --porcelain)" ]]
  }

  git_checkout() {
    local out
    out="$(git checkout "${@}" 2>&1)" \
      || err "${out}"
  }

  git_log() {
    local out
    out="$(git log "${@}" 2>&1)" \
      || err "${out}"
    echo "${out}"
  }

  git_remote_url() {
    git config remote."${REPO_ORIGIN}".url | sed -e 's~^git@\([^:]\+\):~https://\1/~' -e 's/\.git$//'
  }

  diff_url() {
    local url from to
    url=$(git_remote_url)
    from=${1}
    is_valid_version "${from}" \
      && from="v${1}"
    to=${2}
    is_valid_version "${to}" \
      && to="v${2}"
    [[ -n "${url}" ]] \
      && echo "${url}/compare/${from}...${to}" \
      && return
    echo "git diff ${from}..${to}"
  }

  diff_url_esc() {
    sed -e 's/[\/&]/\\&/g' <<< "$(diff_url "${1}" "${2}")"
  }

  git_init() {
    local out
    out="$(git init "${@}" 2>&1)" \
      || err "${out}"
  }

  git_add() {
    local out
    out="$(git add "${@}" 2>&1)" \
      || err "${out}"
  }

  git_commit() {
    local out
    out="$(git commit "${@}" 2>&1)" \
      || err "${out}"
  }

  git_stash() {
    local out
    out="$(git stash "${@}" 2>&1)" \
      || err "${out}"
  }

  git_fetch() {
    local out
    out="$(git fetch --update-head-ok "${@}" 2>&1)" \
      || err "${out}"
  }

  git_tag() {
    local out
    out="$(git tag "${@}" 2>&1)" \
      || err "${out}" >&2
  }

  top_vertag() {
    git tag --list | grep -E "^v[0-9]+\.[0-9]+\.[0-9]+$" | sort -V | tail -1 | tr -d v
  }

  git_merge_nocommit() {
    env GIT_EDITOR=: git merge --no-ff --no-commit "${@}" >/dev/null 2>&1
  }

  git_merge() {
    local out
    out="$(env GIT_EDITOR=: git merge "${@}" 2>&1)" \
      || err "${out}"
  }

  git_show() {
    local out
    out="$(git show "${@}" 2>&1)" \
      || err "${out}"
    echo "${out}"
  }

  git_show_exists() {
    git show "${@}" >/dev/null 2>&1
  }

  latest_commit() {
    git rev-parse "${1}"
  }

  git_rev_list() {
    git rev-list -n1 "${1}"
  }

  git_branch() {
    local out
    out="$(git branch "${@}" 2>&1)" \
      || err "${out}"
  }

  git_branch_format() {
    local out
    out="$(git branch --format='%(refname:short)' "${@}" 2>&1)" \
      || err "${out}"
    echo "${out}"
  }

  git_branch_merged() {
    local out
    out="$(git branch --merged "${@}" 2>&1)" \
      || err "${out}"
    echo "${out}"
  }

  git_push() {
    local out
    out="$(git push "${@}" 2>&1)" \
      || err "${out}"
  }

  checkout_branch() {
    #msg_start "Creating branch '${1}' on '${2}'"
    local out
    out="$(git_checkout -B "${1}" "${2}")" \
      || err "${out}"
    #msg_done
  }

  validate_branch() {
    branch_exists "${1}" \
      && validate_behind "${1}" \
      && return
    [[ ${CONFORM} == 0 ]] \
      && err "Local branch '${1}' not found." 3
    confirm "Create branch '${1}'?"
    create_branch "${1}"
  }

  validate_behind() {
    ! git branch --verbose --list "${1}" | grep --quiet ' \[behind ' \
      && return
    [[ ${CONFORM} == 0 ]] \
      && err "Local branch '${1}' is behind remote." 3
    confirm "Merge branch '${1}' with its remote?"
    update_branch "${1}"
  }

  create_branch() {
    branch_exists "${REPO_ORIGIN}/${1}" \
      && git_branch "${1}" "${REPO_ORIGIN}/${1}" \
      && return
    branch_exists "${REPO_STABLE}" \
      && git_branch "${1}" "${REPO_STABLE}" \
      && return
    git_branch "${1}"
  }

  branch_exists() {
    [[ $(current_branch) == "${1}" ]] \
     || git_branch_format --all | grep -q -E "^${1}\$"
  }

  has_tag() {
    [[ -n $(git tag --merged "${1}" -l "${2}") ]]
  }

  git_repo_exists() {
    [[ -d .git ]]
  }

  validate_git_remote() {
    git config remote."${REPO_ORIGIN}".url >/dev/null \
      || err "Remote url for '${REPO_ORIGIN}' not found."
  }

  current_branch() {
    git_branch_format --show-current
  }

  stash_files() {
    msg_start 'Stashing files'
    git_status_empty \
      && msg_pass \
      && return
    git_add -A
    git_stash push
    msg_done
  }

  is_merged_to() {
    git_branch_merged "${2}" | grep -q "${1}"
  }

  # merge upwards preserving conflicts
  # merge downwards ignoring VERSION and CHANGELOG conflicts
  # upwards: feature->dev->release->master, hotfix->master
  # downwards: master->release->dev
  merge_fromto() {
    local stream
    stream='upwards'
    [[ "${1}" == "${REPO_STABLE}" || "${2}" == "${REPO_DEV}" ]] \
      && stream='downwards'
    [[ "${1}" == "${REPO_DEV}" || "${2}" == "${REPO_STAGING}" ]] \
      && is_attached_to "${REPO_DEV}" "${REPO_STAGING}" \
      && stream='downwards'
    msg_start "Merging '${1}' to '${2}' (${stream})."
    is_merged_to "${1}" "${2}" \
      && msg_pass \
      && return
    git_checkout "${2}"
    git_merge_stream "${1}" "${stream}"
    msg_done
  }

  git_merge_stream() {
    [[ "${2}" == 'upwards' ]] \
      && git_merge --no-ff "${1}" \
      && return
    git_merge_nocommit "${1}"
    git_checkout --ours "${REPO_VERFILE}"
    #TODO: resolve changelog automatically
    #git_checkout --ours "${REPO_CHANGELOG}"
    git_add .
    git_merge --continue
  }

  delete_remote_branch() {
    msg_start "Deleting remote branch '${1}'"
    ! branch_exists "${REPO_ORIGIN}/${1}" \
      && msg_pass \
      && return
    #TODO: used to be:
    #git push "${REPO_ORIGIN}" ":${REFSHEADS}/${1}" 2>&1
    git push -d "${REPO_ORIGIN}" "${1}"
    msg_done
  }

  delete_branch() {
    [[ "$(current_branch)" == "${1}" ]] \
      && err 'Unable to delete checked branch'
    delete_remote_branch "${1}"
    msg_start "Deleting local branch '${1}'"
    git_branch -d "${1}"
    msg_done
  }

  load_version() {
    local branch ver
    branch=${1:-$(current_branch)}
    git_show_exists "${branch}:${REPO_VERFILE}" \
      && ver=$(git_show "${branch}:${REPO_VERFILE}") \
      && is_valid_version "${ver}" \
      && echo "${ver}"
  }

  is_valid_version() {
    [[ "${1}" =~ ^[0-9]+\.[0-9]+\.[0-9]$ ]]
  }

  parse_version() {
    echo "${1}" | sed -n 's/.*\([0-9]\+\.[0-9]\+\.[0-9]\+\).*/\1/p'
  }

  version_gt() {
    ! version_lte "${1}" "${2}"
  }

  version_lte() {
    [[ "${1}" == "$(echo -e "${1}\n${2}" | sort -V | head -n1)" ]]
  }

  validate_requirements() {
    local bash_minv git_minv bash_ver git_ver
    bash_minv=3.2
    git_minv=1.8.0
    bash_ver="$(parse_version "$(bash --version 2>/dev/null)")"
    git_ver="$(parse_version "$(git --version 2>/dev/null)")"
    version_lte "${bash_minv}" "${bash_ver}" \
      || err "Required bash version ${bash_minv} or later."
    version_lte "${git_minv}" "${git_ver}" \
      || err "Required git version ${git_minv} or later."
  }

  # 1) validate repository existence
  # 2) validate repository consistency:
  # - at least one commit
  # - master branch
  validate_repository() {
    git_repo_exists \
      && [[ -n "$(git_branch_format)" ]] \
      && return
    [[ ${INIT} == 0 ]] \
      && ! git_repo_exists \
      && err 'Git repository not found.' 3
    [[ ${INIT} == 0 ]] \
      && [[ -z "$(git_branch_format)" ]] \
      && err 'Missing initial commit.' 3
    [[ "$(ls -A .)" && "${STASH}" == 0 ]] \
      && err 'Folder is not empty.' 5
    confirm "Initialize repository?"
    msg_start 'Initializing repository'
    # this requires newer git version
    #git_init --initial-branch="${REPO_STABLE}"
    ! git_repo_exists \
      && git_init . \
      && git symbolic-ref HEAD "refs/heads/${REPO_STABLE}"
    git_commit --allow-empty -m 'Initial empty commit'
    msg_done
  }

  hotfix_vertag() {
    [[ ${CONFORM} == 0 ]] \
      && err "Invalid version tag 'v${1}' commit." 3
    confirm 'Conform version tag?'
    local ver
    ver=$(increment_patch "${1}")
    update_version "${REPO_STABLE}" "${ver}"
    git_tag "v${ver}" "${REPO_STABLE}"
  }

  validate_tag() {
    local ver
    ver="$(load_version "${REPO_STABLE}")"
    has_tag "${REPO_STABLE}" "v${ver}" \
      && [[ $(git_rev_list "${REFSTAGS}/v${ver}") == "$(latest_commit "${REPO_STABLE}")" ]] \
      && return
    has_tag "${REPO_STABLE}" "v${ver}" \
      && hotfix_vertag "${ver}" \
      && return
    [[ ${CONFORM} == 0 ]] \
      && err "Missing version tag 'v${ver}'." 3
    confirm 'Create version tag?'
    git_tag "v${ver}" "${REPO_STABLE}"
  }

  validate_merged_to() {
    is_merged_to "${1}" "${2}" \
      && return
    [[ ${CONFORM} == 0 ]] \
      && err "Branch '${1}' is not merged into '${2}'." 3
    confirm "Merge branch '${1}' into '${2}'?"
    merge_fromto "${1}" "${2}"
  }

  is_attached_to() {
    [[ $(git_rev_list "${REFSHEADS}/${1}") == $(git_rev_list "${REFSHEADS}/${2}") ]]
  }

  update_version() {
    local gcb
    gcb=$(current_branch)
    msg_start 'Updating version number'
    git_checkout "${1}"
    echo "${2}" > "${REPO_VERFILE}"
    git_add "${REPO_VERFILE}"
    git_commit -am 'Update version number'
    msg_done
    git_checkout "${gcb}"
  }

  # validate git status
  validate_status_empty() {
    git_status_empty \
      && return
    [[ ${STASH} == 1 ]] \
      && stash_files \
      && return
    err 'Uncommitted changes.' 5
  }

  today() {
    date '+%Y-%m-%d'
  }

  default_changelog() {
    local ver url
    ver=$(load_version)
    url=$(git_remote_url)
    echo "${REPO_changelog_stamp}"
    echo
    echo "## [${ver}] - $(today)"
    echo
    echo "### Added"
    echo
    echo " - This CHANGELOG file."
    echo
    [[ -n "${url}" ]] \
      && echo "[${ver}]: ${url}/releases/tag/v${ver}" \
      && return
    echo "[${ver}]"
  }

  restore_changelog() {
    [[ -z "${1}" ]] \
      && default_changelog > "${REPO_CHANGELOG}" \
      && return
    git_show "${1}:${REPO_CHANGELOG}" > "${REPO_CHANGELOG}"
  }

  # 1: branch
  # 2: restore from branch, empty for create new
  # 3: stamp, e.g. version number or "Unreleased"
  # 4: note, e.g. date
  # 5: diff from
  # 6: diff to
  validate_changelog() {
    git_show_exists "${1}:${REPO_CHANGELOG}" \
      && [[ -n $(git_show "${1}:${REPO_CHANGELOG}") ]] \
      && git_show "${1}:${REPO_CHANGELOG}" | grep -q "^## \[${3}]" \
      && git_show "${1}:${REPO_CHANGELOG}" | grep -q "^\[${3}]" \
      && return
    [[ ${CONFORM} == 0 ]] \
      && err "Missing or invalid changelog file on ${1}." 3
    confirm "Conform changelog file on ${1}?"
    local gcb
    gcb=$(current_branch)
    git_checkout "${1}"
    # changelog must exist and must be unempty
    [[ ! -f "${REPO_CHANGELOG}" || ! -s "${REPO_CHANGELOG}" ]] \
      && restore_changelog "${2}"
    # changelog must contain some heading and diff stamp
    # shellcheck disable=SC2015
    grep -q '^## ' "${REPO_CHANGELOG}" \
      && grep -q '^\[' "${REPO_CHANGELOG}" \
      || restore_changelog "${2}"
    changelog_stamp "${3}" "${4}" "${5}" "${6}"
    git_add -- "${REPO_CHANGELOG}"
    git_commit -am "Conform changelog file on '${1}'"
    git_checkout "${gcb}"
  }

  # 1: branch
  # 2: min version
  validate_version() {
    local ver
    ver=$(load_version "${1}")
    [[ -n "${ver}" ]] \
      && ! version_gt "${2:-0.0.0}" "${ver}" \
      && return
    [[ ${CONFORM} == 0 ]] \
      && err "Missing or invalid version file on ${1}." 3
    confirm "Conform version file on ${1}?"
    local gcb
    gcb=$(current_branch)
    git_checkout "${1}"
    echo "${2:-0.0.0}" > "${REPO_VERFILE}"
    git_add "${REPO_VERFILE}"
    git_commit -am "Conform version file on ${1}"
    git_checkout "${gcb}"
  }

  find_or_first() {
    for branch in "${@}"; do
      branch_exists "${branch}" \
        && echo "${branch}" \
        && return
    done
    for branch in "${@}"; do
      branch_exists "${REPO_ORIGIN}/${branch}" \
        && echo "${branch}" \
        && return
    done
    echo "${1}"
  }

  flow_validate() {
    [[ ${#} -gt 1 ]] \
      && err 'Too many arguments.' 2
    local gcb=${REPO_DEV}
    validate_requirements
    git_repo_exists \
      && gcb=$(current_branch)
    validate_repository
    validate_status_empty
    REPO_STABLE=$(find_or_first "${REPO_STABLE}" "${STABLE_ARR[@]}")
    REPO_STAGING=$(find_or_first "${REPO_STAGING}" "${STAGING_ARR[@]}")
    REPO_DEV=$(find_or_first "${REPO_DEV}" "${DEV_ARR[@]}")
    validate_branch "${REPO_STABLE}"
    validate_version "${REPO_STABLE}" "$(top_vertag)"
    local from to
    from=$(load_version "${REPO_STABLE}")
    to=$(increment_patch "${from}")
    # looking for the "from" stamp, else create an incremented stamp from to
    validate_changelog "${REPO_STABLE}" "" "${from}" "$(today)" "${from}" "${to}"
    validate_tag
    validate_prod_branch
    validate_branch "${REPO_STAGING}"
    validate_branch "${REPO_DEV}"
    validate_merged_to "${REPO_STABLE}" "${REPO_DEV}"
    ! is_attached_to "${REPO_STABLE}" "${REPO_STAGING}" \
      && validate_merged_to "${REPO_STABLE}" "${REPO_STAGING}" \
      && validate_version "${REPO_STAGING}" "$(increment_minor "$(load_version "${REPO_STABLE}")")" \
      && validate_changelog "${REPO_STAGING}" "${REPO_STABLE}" "$(load_version "${REPO_STAGING}")" "RC1" "${from}" "${REPO_STAGING}" \
      && from=${REPO_STAGING}
    validate_merged_to "${REPO_STAGING}" "${REPO_DEV}"
    validate_version "${REPO_DEV}" "$(increment_minor "$(load_version "${REPO_STAGING}")")"
    validate_changelog "${REPO_DEV}" "${REPO_STAGING}" "${UNRELEASED}" "" "${from}" "${REPO_DEV}"
    validate_param "${1:-}"
    validate_param "${DEFAULT_HOTFIX}"
    validate_param "${DEFAULT_FEATURE}"
    git_checkout "${gcb}"
  }

  is_prod_branch() {
    [[ "${1}" =~ ^${REPO_PROD}-[0-9]+$ ]]
  }

  # prod* must exist
  # else optional
  validate_param() {
    [[ -z "${1}" ]] \
      && return
    branch_exists "${REPO_ORIGIN}/${1}" \
      && ! branch_exists "${1}" \
      && git_branch "${1}" "${REPO_ORIGIN}/${1}"
    ! branch_exists "${1}" \
      && ! is_prod_branch "${1}" \
      && return
    ! branch_exists "${1}" \
      && err "Expected branch '${1}' not found." 4
    validate_behind "${1}"
  }

  prod_name() {
    local ver
    ver="${1:-$(load_version "${REPO_STABLE}")}"
    echo "${REPO_PROD}-${ver%%.*}"
  }

  validate_prod_branch() {
    local prod
    prod=$(prod_name)
    validate_branch "${prod}"
    is_attached_to "${prod}" "${REPO_STABLE}" \
      && return
    [[ ${CONFORM} == 0 ]] \
      && err "Branch '${prod}' is behind '${REPO_STABLE}'." 3
    confirm "Merge branch '${prod}' into '${REPO_STABLE}'?"
    git_checkout "${prod}"
    git_merge "${REPO_STABLE}"
  }

  get_key_branch() {
    [[ " ${STABLE_ARR[*]} " == *" ${1} "* ]] \
      && echo "${REPO_STABLE}" \
      && return
    [[ " ${STAGING_ARR[*]} " == *" ${1} "* ]] \
      && echo "${REPO_STAGING}" \
      && return
    [[ " ${DEV_ARR[*]} " == *" ${1} "* ]] \
      && echo "${REPO_DEV}" \
      && return
    echo "${1}"
  }

  is_hotfix_branch() {
    [[ "$(git merge-base "${1}" "${REPO_DEV}")" == "$(git merge-base "${REPO_STABLE}" "${REPO_DEV}")" ]]
  }

  # 1: dest branch
  # 2: source branch or empty
  flow_hotfix() {
    branch_exists "${1}" \
      && release_hotfix "${1}" \
      && return
    local branch="${REPO_STABLE}"
    [[ "$(is_prod_branch "$(current_branch)")" ]] \
      && branch=$(current_branch)
    [[ -n "${2:-}" ]] \
      && branch="${2}"
    create_hotfix "${1}" "${branch}"
  }

  # 1: dest branch
  flow_feature() {
    branch_exists "${1}" \
      && release_feature "${1}" \
      && return
    create_feature "${1}"
  }

  flow_process() {
    local branch
    branch=$(get_key_branch "${1:-"$(current_branch)"}")
    git check-ref-format "${REFSHEADS}/${branch}" \
      && [[ "${branch,,}" != "head" ]] \
      || err "Invalid branch name." 2
    # flow dev* -> release dev
    [[ "${branch}" == "${REPO_DEV}" ]] \
      && release_dev \
      && return
    # flow staging* -> release staging
    [[ "${branch}" == "${REPO_STAGING}" ]] \
      && release_staging \
      && return
    # flow stable* -> create/release default hotfix
    [[ "${branch}" == "${REPO_STABLE}" ]] \
      && flow_hotfix "${DEFAULT_HOTFIX}" "${REPO_STABLE}" \
      && return
    # flow prod* -> create/release (default?) hotfix on a prod* branch
    is_prod_branch "${branch}" \
      && flow_hotfix "${DEFAULT_HOTFIX}" "${branch}" \
      && return
    # flow hotfix -> create/release default hotfix on a stable or prod* branch
    [[ "${branch}" == "${HOTFIX}" ]] \
      && flow_hotfix "${DEFAULT_HOTFIX}" \
      && return
    # flow feature -> create/release default feature
    [[ "${branch}" == "${FEATURE}" ]] \
      && flow_feature "${DEFAULT_FEATURE}" \
      && return
    # flow other existing hotfix branch -> release hotfix
    branch_exists "${branch}" \
      && is_hotfix_branch "${branch}" \
      && release_hotfix "${branch}" \
      && return
    # if other existing branch -> release feature
    branch_exists "${branch}" \
      && release_feature "${branch}" \
      && return
    # if on stable|prod -> create hotfix branch
    is_hotfix_branch "$(current_branch)" \
      && create_hotfix "${1}" "$(current_branch)" \
      && return
    # create feature branch
    create_feature "${1}"
  }

  release_dev() {
    confirm "* Release '${REPO_DEV}' branch?"
    msg_start 'Releasing dev'
    git_checkout "${REPO_DEV}"
    local from to nthrc
    from=$(load_version "${REPO_STABLE}")
    to=$(load_version "${REPO_DEV}")
    nthrc=$(( $(grep -c "^\[${to//./\.}]" "${REPO_CHANGELOG}") + 1 ))
    sed -i "s/^## \[${UNRELEASED}].*/## [${to}] - RC${nthrc}/" "${REPO_CHANGELOG}"
    is_attached_to "${REPO_STAGING}" "${REPO_STABLE}" \
      && sed -i "s/^\[${UNRELEASED}].*/[${to}]: $(diff_url_esc "${from}" "${REPO_STAGING}")/" "${REPO_CHANGELOG}"
    sed -i "/^\[${UNRELEASED}]/d" "${REPO_CHANGELOG}"
    git_add -- "${REPO_CHANGELOG}"
    git_commit -am 'Update changelog'
    merge_fromto "${REPO_DEV}" "${REPO_STAGING}"
    merge_fromto "${REPO_STAGING}" "${REPO_DEV}"
    [[ "${nthrc}" == 1 ]] \
      && increment_minor "$(load_version)" > "${REPO_VERFILE}" \
      && changelog_stamp "${UNRELEASED}" "" "${REPO_STAGING}" "${REPO_DEV}" \
      && git_commit -am "Increment minor version on '${REPO_DEV}'"
    msg_done
    git_checkout "${REPO_STAGING}"
  }

  create_feature() {
    confirm "* Create branch '${1}' from '${REPO_DEV}'?"
    checkout_branch "${1}" "${REPO_DEV}"
  }

  # 1 dest name
  # 2 source branch
  create_hotfix() {
    confirm "* Create hotfix '${1}' from '${2}'?"
    checkout_branch "${1}" "${2}"
  }

  release_staging() {
    # shellcheck disable=SC2015
    [[ ${REQUEST} == 1 ]] \
      && confirm "* Request merge '${REPO_STAGING}' to '${REPO_STABLE}'?" \
      || confirm "* Release '${REPO_STAGING}' branch to '${REPO_STABLE}'?"
    is_attached_to "${REPO_STAGING}" "${REPO_STABLE}" \
      && err 'Staging branch is already released.' 6
    merge_fromto "${REPO_STABLE}" "${REPO_STAGING}"
    msg_start 'Updating changelog'
    local from to
    from=$(load_version "${REPO_STABLE}")
    to=$(load_version)
    sed -i "0,/^## \[${to//./\.}].*/s//## [${to}] - $(today)/" "${REPO_CHANGELOG}"
    sed -i "s/^\[${to//./\.}].*/[${to}]: $(diff_url_esc "${from}" "${to}")/" "${REPO_CHANGELOG}"
    git_add -- "${REPO_CHANGELOG}"
    git_commit -am 'Update changelog'
    msg_done
    [[ ${REQUEST} == 1 ]] \
      && flow_request "${REPO_STABLE}" \
      && return
    msg_start 'Updating branching structure'
    merge_fromto "${REPO_STAGING}" "${REPO_STABLE}"
    git_tag "v${to}"
    git_checkout "${REPO_STAGING}"
    git_merge "${REPO_STABLE}"
    local prod
    prod=$(prod_name)
    # shellcheck disable=SC2015
    branch_exists "${prod}" \
      && git_checkout "${prod}" \
      && git_merge "${REPO_STABLE}" \
      || git_branch "${prod}"
    merge_fromto "${REPO_STABLE}" "${REPO_DEV}"
    msg_done
  }

  # 1: stamp
  # 2: note
  # 3: from
  # 4: to
  changelog_stamp() {
    local heading diff
    heading="## [${1}] - ${2}"
    diff="[${1}]: $(diff_url_esc "${3}" "${4}")"
    [[ "${1}" == "${3}" ]] \
        && heading="## [${4}] - ${2}" \
        && diff="[${4}]: $(diff_url_esc "${3}" "${4}")"
    # add heading stamp if not exists
    ! grep -q "^## \[${1}]" "${REPO_CHANGELOG}" \
      && sed -i "0,/^## /s//${heading%* - }\n\n&/" "${REPO_CHANGELOG}"
    # add diff stamp if not exists
    ! grep -q "^\[${1}]" "${REPO_CHANGELOG}" \
      && sed -i "0,/^\[/s//${diff}\n&/" "${REPO_CHANGELOG}"
  }

  # 1: keyword
  # 2: message
  add_changelog_entry() {
    local tmpfile
    tmpfile="$(mktemp)"
    gawk -v kw="${1}" -v msg="${2}" -v kws="${KEYWORDS[*]#*${1}}" '
      function add_entry () {
        print "### " kw
        print ""
        print " - " msg
        print ""
      }
      BEGIN {
        before = 1
        after = 0
      }
      /^$/ {
        print
        next
      }
      /^## \[/ && before == 1 && after == 0 {
        before = 0
        print
        next
      }
      /^## \[/ && before == 0 {
        if (after == 0) {
          add_entry()
        }
        after = 1
        print
        next
      }
      before == 1 || after == 1 {
        print
        next
      }
      $0 ~ "^### " kw {
        print
        getline
        print
        print " - " msg
        after = 1
        next
      }
      $0 ~ "^### " kws {
        add_entry()
        print
        after = 1
        next
      }
      {
        print
      }
    ' "${REPO_CHANGELOG}" > "${tmpfile}"
    mv "${tmpfile}" "${REPO_CHANGELOG}"
  }

  # 1: default keyword
  # 2: source branch
  update_changelog() {
    local gcb kw=
    gcb=$(current_branch)
    [[ "${ENTRY}" == 1 ]] \
      && add_changelog_entry "${1}" "${gcb}" \
      && return
    echo
    echo '***'
    echo "* Please enter the ${gcb} description for ${REPO_CHANGELOG}."
    echo '*'
    echo '* Supported keywords:'
    echo "*   ${KEYWORDS[*]}"
    echo '*'
    echo "* Commits of '${gcb}':"
    git_log "${2}".."${gcb}" --pretty=format:'*   %h %s'
    echo '*'
    echo '***'
    # What for?
    REPLY=
    [[ ${ISSTDIN} == 0 ]] \
      && echo 'Type "[Keyword]: [Message]". Empty line to end editing.' \
      && echo "If omitted, the default keyword is '${1}'." \
      && echo "Leave empty (press Enter) for default message: '${1}: ${gcb}'." \
      && clear_stdin
    while read -e -r line; do
      [[ -z "${line}" ]] \
        && break
      history -s "${line}"
      kw="${line%%:*}"
      [[ " ${KEYWORDS[*]} " != *" ${kw} "* ]] \
        && kw=${1}
      add_changelog_entry "${kw}" "$(echo "${line#*:}" | xargs)"
    done
    [[ -z "${kw}" ]] \
      && add_changelog_entry "${1}" "${gcb}"
  }

  release_feature() {
    is_merged_to "${1}" "${REPO_DEV}" \
      && err 'Nothing to merge.' 6
    # shellcheck disable=SC2015
    [[ ${REQUEST} == 1 ]] \
      && confirm "* Request merge '${1}' into '${REPO_DEV}'?" \
      || confirm "* Merge '${1}' into '${REPO_DEV}'?"
    merge_fromto "${REPO_DEV}" "${1}"
    update_changelog Added "${REPO_DEV}"
    git_commit -am 'Update changelog'
    [[ ${REQUEST} == 1 ]] \
      && flow_request "${REPO_DEV}" \
      && return
    merge_fromto "${1}" "${REPO_DEV}"
    delete_branch "${1}"
  }

  # 1: version
  # 2: major|minor|patch
  increment_version() {
    local major minor patch
    major=$(echo "${1}" | cut -d. -f1)
    minor=$(echo "${1}" | cut -d. -f2)
    patch=$(echo "${1}" | cut -d. -f3)
    case "${2:-}" in
      major)
        (( major ++ ))
        minor=0
        patch=0
        ;;
      minor)
        (( minor ++ ))
        patch=0
        ;;
      patch)
        (( patch ++ ))
        ;;
      *)
        err 'Version increment parameter missing or invalid.'
    esac
    echo "${major}.${minor}.${patch}"
  }

  increment_patch() {
    increment_version "${1}" patch
  }

  increment_minor() {
    increment_version "${1}" minor
  }

  release_hotfix() {
    local dest vers verd
    dest=${REPO_STABLE}
    vers=$(load_version "${1}")
    verd=$(load_version "${REPO_STABLE}")
    [[ "${vers%%.*}" > "${verd%%.*}" ]] \
      && err "Hotfix version is greater than '${REPO_STABLE}'." 4
    [[ "${vers%%.*}" < "${verd%%.*}" ]] \
      && dest="$(prod_name "${vers}")" \
      && verd="$(load_version "${dest}")"
    ! branch_exists "${dest}" \
      && err "Branch '${dest} not found." 4
    is_merged_to "${1}" "${dest}" \
      && err 'Nothing to merge.' 6
    # shellcheck disable=SC2015
    [[ "${dest}" == "${REPO_STABLE}" ]] \
      && confirm '* Release the hotfix?' \
      || confirm "* Obsolete major version. Merge to branch '${dest}'?"
    msg_start 'Updating control files'
    increment_patch "${verd}" > "${REPO_VERFILE}"
    local verh
    verh=$(increment_patch "${verd}")
    changelog_stamp "${verh}" "$(today)" "${verd}" "${verh}"
    update_changelog Fixed "${dest}"
    git_commit -am 'Update control files'
    msg_done
    [[ ${REQUEST} == 1 ]] \
      && flow_request "${dest}" \
      && return
    merge_fromto "${1}" "${dest}"
    git_tag "v$(load_version)"
    [[ "${dest}" != "${REPO_STABLE}" ]] \
      && delete_branch "${1}" \
      && return
    git_checkout "$(prod_name "${verd}")"
    git_merge "${REPO_STABLE}"
    verr=$(load_version "${REPO_STAGING}")
    [[ "${verr%.*}" == "${verd%.*}" ]] \
      && git_checkout "${REPO_STAGING}" \
      && git_merge "${REPO_STABLE}" \
      && merge_fromto "${REPO_STABLE}" "${REPO_DEV}" \
      && delete_branch "${1}" \
      && return
    merge_fromto "${REPO_STABLE}" "${REPO_STAGING}"
    merge_fromto "${REPO_STAGING}" "${REPO_DEV}"
    delete_branch "${1}"
  }

  update_branch() {
    checkout_branch "${1}" "${REPO_ORIGIN}/${1}"
    git_merge --ff-only "${REPO_ORIGIN}/${1}"
    git_branch --set-upstream-to="${REPO_ORIGIN}/${1}"
  }

  flow_pull() {
    validate_git_remote
    confirm '* Pull all remote branches?'
    msg_start 'Pulling branches'
    git_fetch --all --tags
    for branch in $(git_branch_format -r | grep "^${REPO_ORIGIN}" | sed "s/^${REPO_ORIGIN}\///"); do
      [[ "${branch}" == HEAD ]] \
        && continue
      update_branch "${branch}"
    done
    msg_done
  }

  flow_push() {
    validate_git_remote
    confirm '* Push all branches to the remote repository?'
    msg_start 'Pushing all branches and tags'
    git_push "${REPO_ORIGIN}" --all --tags
    msg_done
  }

  flow_request() {
    validate_git_remote
    [[ "${REPO_ORIGIN}" == "${REPO_UPSTREAM}" ]] \
      || git_push "${REPO_ORIGIN}" "${1}"
    git_push "${REPO_ORIGIN}" "${1}"
    flow_request_url "${1}"
  }

  trim_url() {
    local url
    url="${1#https://}"
    echo "${url}" | grep -q ":" \
      && url="${url#*@}" \
      && url="${url/://}" \
      && url="${url/.git/}"
    echo "${url}"
  }

  flow_request_url() {
    local url upstream_url to gcb
    to="${1:-${REPO_DEV}}"
    url=$(trim_url "$(git config remote."${REPO_ORIGIN}".url)")
    upstream_url="$(git config remote."${REPO_UPSTREAM}".url)"
    upstream_url="$(trim_url "${upstream_url}")"
    gcb=$(current_branch)
    echo -n 'Pull request URL: '
    case "${url}" in
      *"${GITHUB}"*)
        # shellcheck disable=SC1003
        [[ "${url}" == "${upstream_url}" ]] \
          && echo "https://${url}/compare/${to}...${gcb}?expand=1" \
          || echo "https://${upstream_url}/compare/${to}...$(echo "${url}" | cut -d'/' -f2)%3A${gcb}?expand=1"
      ;;
      *"${BITBUCKET}"*)
        # shellcheck disable=SC1003
        [[ "${url}" == "${upstream_url}" ]] \
          && echo "https://${url}/compare/${gcb}..$(echo "${url}" | cut -d'/' -f2-3)%3A${to}" \
          || echo "https://${url}/compare/${gcb}..$(echo "${upstream_url}" | cut -d'/' -f2-3)%3A${to}"
      ;;
      *)
        err 'Unsupported remote server name.'
      ;;
    esac
  }

  flow_usage() {
    local file head tail
    head="$(echo "${FLOW_USAGE:-}" | head -n1)"
    tail="$(echo "${FLOW_USAGE:-}" | tail -n+2)"
    file="${FLOW_DATAPATH}/${SCRIPT_NAME}.usage"
    [[ -z "${head}" ]] \
      && [[ ! -f "${file}" ]] \
      && echo 'Usage is not available in source file.' \
      && return
    [[ -z "${head}" ]] \
      && head="$(head -n1 "${file}")" \
      && tail="$(tail -n+2 "${file}")"
    echo "${head}"
    echo
    local indent=0
    [[ ${COLUMNS} -gt 1 ]] \
      && indent=5 \
      && export MANWIDTH=$(( COLUMNS + indent ))
    echo "${tail}" | man --nj --nh -l - 2>/dev/null \
      | sed "1,2d;/^[[:space:]]*$/d;\${d};s/^ \{${indent}\}//"
  }

  flow_version() {
    [[ -n "${FLOW_VERNUM}" ]] \
      && echo "flow ${FLOW_VERNUM}" \
      && return
    echo "flow $(<"${FLOW_VERFILE}")"
  }

  flow_whatnow() {
    local branch
    branch=$(current_branch)
    [[ -z "${branch}" ]] \
      && err 'Detached branch.' 6
    echo '***'
    echo "* Flow on '${branch}'"
    echo '*'
    branch_desc "${branch}"
    echo '***'
  }

  branch_desc() {
    [[ "${1}" == "${REPO_STABLE}" || "$(is_prod_branch "${1}")" ]] \
      && echo '* This is considered a read-only stable branch.' \
      && echo '* Do not commit any changes directly to this branch ever!' \
      && echo '*' \
      && echo "* 1. Run '${SCRIPT_NAME}' to create a hotfix or leave." \
      && return
    [[ "${1}" == "${REPO_STAGING}" ]] \
      && echo '* This branch is meant solely for bug fixing.' \
      && echo '* Each commit must be merged into the development branch.' \
      && echo '*' \
      && echo '* 1. Make some fixes and feel free to commit directly.' \
      && echo "* 2. Run '${SCRIPT_NAME}' to release this branch." \
      && return
    [[ "${1}" == "${REPO_DEV}" ]] \
      && echo '* This is a development branch.' \
      && echo '* It is designed for bug fixing and merging features.' \
      && echo '*' \
      && echo '* 1. Make some fixes and feel free to commit directly.' \
      && echo "* 2. Run '${SCRIPT_NAME} feature_name' to create a new feature." \
      && echo "* 3. Run '${SCRIPT_NAME}' to release this branch." \
      && return
    is_hotfix_branch "${1}" \
      && echo '* This is a temporary hotfix branch created from a stable branch.' \
      && echo '* Its purpose is to fix one critical problem and dissolve.' \
      && echo '* WARNING: Make only minimum necessary changes here!' \
      && echo '*' \
      && echo '* 1. Make sure you really HAVE to hotfix the problem.' \
      && echo '* 2. Fix the critical problem and commit changes.' \
      && echo "* 3. Run '${SCRIPT_NAME}' to merge the hotfix back into stable branch." \
      && echo '* 4. Good luck.' \
      && return
    echo '* This is a temporary feature branch.'
    echo '* Its purpose is to create a (one) new feature.'
    echo '*'
    echo '* 1. Create and develop the feature. One feature is a perfect amount.'
    echo "* 2. Run '${SCRIPT_NAME}' to merge it back into dev."
  }

  # global constants
  declare -r SCRIPT_NAME=${0##*/}
  declare -r GREEN=2
  declare -r BLUE=4
  declare -r GITHUB='github.com'
  declare -r BITBUCKET='bitbucket.org'
  declare -r HOTFIX='hotfix'
  declare -r DEFAULT_HOTFIX="${HOTFIX}-$(whoami)"
  declare -r FEATURE='feature'
  declare -r DEFAULT_FEATURE="${FEATURE}-$(whoami)"
  declare -r UNRELEASED='Unreleased'
  declare -r KEYWORDS=(Added Changed Deprecated Removed Fixed Security)
  declare -r REFSHEADS='refs/heads'
  declare -r REFSTAGS='refs/tags'
  declare -r STABLE_ARR=(main master production prod live)
  declare -r STAGING_ARR=(staging release rc preprod release-candidate)
  declare -r DEV_ARR=(dev devel develop next)
  declare USAGE
  USAGE=$(flow_usage)
  declare VERSION
  VERSION=$(flow_version)

  # process options
  line=$(IFS=' ' getopt -n "${0}" \
    -o cehinrsvVwy\? \
    -l conform,color::,colour::,auto-entry,help,init,dry-run,request,stash,verbose,version,what-now,yes,pull,push \
    -- "${@}" 2>&1) \
    || err "${line}" 2
  eval set -- "${line}"

  # global variables
  [ -t 0 ]
  declare ISSTDIN=${?}
  declare WHATNOW=0
  declare DRYRUN=0
  declare ENTRY=0
  declare VERBOSE=0
  declare YES=0
  declare COLOR=auto
  declare POSX=1
  declare POSY=1
  declare STASH=0
  declare CONFORM=0
  declare INIT=0
  declare REQUEST=0
  declare PUSH=0

  while [[ ${#} -gt 0 ]]; do
    case ${1} in
     -c|--conform) CONFORM=1; shift ;;
     -e|--auto-entry) ENTRY=1; shift ;;
     --color|--colour) shift; setcolor "${1}"; shift ;;
     -s|--stash) STASH=1; shift ;;
     -h|-\?|--help) echo "${USAGE}"; exit ;;
     -i|--init) INIT=1; CONFORM=1; shift ;;
     -n|--dry-run) DRYRUN=1; shift ;;
     --pull) flow_pull; exit ;;
     --push) PUSH=1; shift ;;
     -r|--request) REQUEST=1; shift ;;
     -v|--verbose) VERBOSE=1; shift ;;
     -V|--version) echo "${VERSION}"; exit ;;
     -w|--what-now) flow_whatnow; exit ;;
     -y|--yes) YES=1; shift ;;
      --) shift; break ;;
      *-) err "Unrecognized option '${1}'." 2 ;;
       *) break ;;
    esac
  done

  # process
  flow_validate "${@}"
  [[ ${INIT} == 1 ]] \
    && git_checkout "${REPO_DEV}" \
    && exit
  [[ ${PUSH} == 1 ]] \
    && flow_push \
    && exit
  flow_process "${@}"

}

main "${@}"
